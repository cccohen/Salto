// Salto
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------Variables----------------------------------------
// scale factor for myelin, accounting for the difference in surface area between
// the myelin sheath and axon core. Based on g and ratio entered at setup.
smy = 1/(gr = getvar(ses, "gr.dat"))
// to contain internode numbers (including paranodal sections) requested for demyelination
// by function demyelinate(int1, int2, ..., intn). Each internode number corresponds to the
// same index number in the intlist created by demyelinate().
objref demyvec

demyvec = new Vector()
// --------------------------------------------------------------------------------



// --------------------------------setmy-------------------------------------------
// set myelin parameters according to the the myelin scale (smy)
// to account for myelin dimensions (i.e. extra radius over that of the axon core)
// and the extra surface area that affords to the myelin structure to accordingly 
// scale any myelin-specific parameters in axon types involving myelin.
proc setmy() {local k, m, seg, pos, dist_, Kv7_ais_distal

	forsec internodal {

		if (DC || DCPARA) {

			xg[0] *= smy
			xc[0] *= smy
		}
		
		if (SC) {

			g_pas = 1/((Rm_norm * Rm_low) + ((Rmy_norm * Rmy_low)/smy))
			cm = (Cm_norm * Cm_low * Cmy_norm * Cmy_low * smy)/((Cm_norm * Cm_low) + (Cmy_norm * Cmy_low * smy))

			if (per_int_doarg) {
			
				for k = 0, intlist.count-1 {

					for m = 0, intlist.o(k).size-1 {

						axon[intlist.o(k).x[m]] {

							sprint(tempstr, "%s%d%s%d%s", "~g_pas = 1/((Rm_norm * Rm_low) + ((Rmy_", k+1, "_norm * Rmy_", k+1, "_low)/smy))")
							execute(tempstr)

							sprint(tempstr, "%s%d%s%d%s%d%s%d%s", "~cm = (Cm_norm * Cm_low * Cmy_", k+1, "_norm * Cmy_", k+1, "_low * smy)/((Cm_norm * Cm_low) + (Cmy_", k+1, "_norm * Cmy_", k+1, "_low * smy))")
							execute(tempstr)
						}
					}
				}
			}

			if (RmA_doarg) {

				g_pas = 1/((RmA_norm * RmA_low) + ((Rmy_norm * Rmy_low)/smy))
			}

			if (RmI_doarg) {

				g_pas = 1/((RmI_norm * RmI_low) + ((Rmy_norm * Rmy_low)/smy))
			}

			if (exp_doarg) {

				g_pas = 1/((Rm_norm * Rm_low) + (Rm_norm * 20 * Rmy_low)/smy)
				cm = (Cm_norm * Cm_low * (Cm_norm/20) * Cm_low * smy)/((Cm_norm * Cm_low) + ((Cm_norm/20) * Cm_low * smy))
			}			
		}
	}

	if (demyvec.size) {

		demy()
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc demyelinate() {local i, k, nint
	// i has to be a local variable to use $i	
	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter number corresponding to each internode to demyelinate, starting at 1 (separated by commas)."
			print "To discover the number of internodes, try nint(). To demyelinate all internodes, try demyall()."
			stop
		}
	}	

	demyvec.resize(nint = crintlist())	

	for i = 1, numarg() {

		for k = 0, nint-1 {

			if ($i-1 == k) {
			
				demyvec.x[k] = 1
				print "Demyelinating internode... ", $i
			}
		}
	}

	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc remyelinate() {

	print "Remyelinating all internodes..."	
	
	demyvec.resize(0)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc demy() {local k, m, nodnum, countseg_ais, countseg_juxta, countseg_para, countseg_nod, countseg_bleb, countseg, seg, pos, r localobj tempvec

	if (DC || DCPARA) {

		for k = 0, demyvec.size-1 {

			// demyelinate internode k
			if (demyvec.x[k]) {	
	
				for m = 0, intlist.o(k).size-1 {

					axon[intlist.o(k).x[m]] {

						xg[0] = 1/Rext
						xc[0] = 0
						xraxial[0] = rext
					}

					if (mode_ == 1) {
					// Rearrange ion channel distribution, a consequence of demyelination in cuprizone models or MS tissue.
					
					// NaV: greater presence at formerly paranodal regions, but not beyond (Coman et al. 2006 [MS], Hamada et al. 2015 [cuprizone]).
					// Note: may not apply at first paranode (Hamada et al. 2015)
					// Kv1: greater presence at formerly paranodal regions, but not beyond (Nie et al. 2003 [Nogo-A KO]).
					// Note: since no explicit evidence of application at first paranode, and no clear evidence of a Nogo-specific effect in
					// MS tissue, not applied anywhere.
					// Kv7.3: greater presence at formerly paranodal and juxtaparanodal regions (Hamada et al. 2015 [cuprizone]). Since AIS/nodes seem to have 
					// much more Kv7 than internodes, the conservative assumption is uniform redistribution 
					// Note: since explicit evidence of application at first paranode and juxtaparanode, applied there.
					
					// Regarding the method of redistribution, the most conservative assumption is made: that no new channels
					// are created, and therefore only redistributed, uniformly, from adjacent regions with higher densities.
					// The redistribution strategy, therefore, consists of counting number of "original" segments and the total number of segments affected,
					// then multiplying down the densities in original regions with original/total segments, and adding in the same in the affected regions,
					// of the same quantity as the most adjacent original segment.
					// A different application of the strategy results in the AIS region/first paranode/juxtaparanode, and therefore the first internode
					// is singled out for special application first. Thereafter, the more general version of the strategy applies. 
					// A similar issue as the first internode is faced at the last, if adjacent to a non-myelinated bleb, and is treated accordingly as the first.

						// k counts internodes
						// if first internode
						if (k == 0) {

							// m counts internodal segments
							if (m == 0) {

								// count relevant segments
								countseg_ais = 0
								countseg_para = 0
								countseg_juxta = 0

								forsec AIS {

									countseg_ais += nseg
								}

								axon[intlist.o(k).x[m]] {

									for seg = 1, nseg {
									
										pos = (2*seg-1)/(2*nseg)
										dist_ = getdist(secname(), 0, secname(), pos)

										if (dist_ <= paral) {

											countseg_para += 1
										}

										if (dist_ > paral && dist_ <= paral+juxtal) {

											countseg_juxta += 1
										}
									}
								}
								
								// count segments across sections belonging to the same sectionlist
								countseg = 0

								forsec AIS {

									for seg = 1, nseg {

										pos = (2*seg-1)/(2*nseg)

										countseg += 1

										if (countseg == countseg_ais) {

											tempvec = new Vector(1)
											// last AIS Kv7 adjacent to the first paranode
											tempvec.x[0] = gbar_kv7(pos)

											// conservative demyelination, as a strategy, consists of uniform redistribution of channel densities
											// from a adjacent regions. Less conservative demyelination would consist of adding channel densities (perhaps equally)
											// to an affected region, leaving adjacent regions unchanged.
											gbar_kv7(pos) *= (countseg_para+countseg_juxta)/(1+countseg_para+countseg_juxta)
										}
									}
								}

								axon[intlist.o(k).x[m]] {

									for seg = 1, nseg {
									
										pos = (2*seg-1)/(2*nseg)
										dist_ = getdist(secname(), 0, secname(), pos)

										if (dist_ <= paral+juxtal) {

											gbar_kv7(pos) = ((countseg_para+countseg_juxta)/(1+countseg_para+countseg_juxta)) * tempvec.x[0]
										}
									}
								}
							}

							if (m == intlist.o(k).size-1) {

								if (nodlist.count) {

									countseg_nod = 0
									countseg_para = 0
									countseg_juxta = 0

									// NaV/Kv7 storage vector
									tempvec = new Vector(2)

									for r = 0, nodlist.o(k).size-1 {

										axon[nodlist.o(k).x[r]] {

											countseg_nod += nseg

											// store the nodal values (distributed uniformly throughout the node)
											if (r == nodlist.o(k).size-1) {

												tempvec.x[0] = gbar_nax
												tempvec.x[1] = gbar_kv7
											}
										}
									}

									axon[intlist.o(k).x[m]] {

										for seg = 1, nseg {
										
											pos = (2*seg-1)/(2*nseg)
											dist_ = getdist(secname(), 1, secname(), pos)

											if (dist_ <= paral) {

												countseg_para += 1
											}

											if (dist_ > paral && dist_ <= paral+juxtal) {

												countseg_juxta += 1
											}
										}
									}

									for r = 0, nodlist.o(k).size-1 {

										axon[nodlist.o(k).x[r]] {	
												
											// NaV: spreads to para only
											gbar_nax = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
											// Kv7: spreads to para and juxta
											gbar_kv7 = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
										}
									}

									// apply downscaling to internode
									axon[intlist.o(k).x[m]] {

										for seg = 1, nseg {
										
											pos = (2*seg-1)/(2*nseg)
											dist_ = getdist(secname(), 1, secname(), pos)

											if (dist_ <= paral) {

												gbar_nax(pos) = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
												gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
											}

											if (dist_ > paral && dist_ <= paral+juxtal) {

												gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
											}
										}
									}

									// store the downscaling event
									sprint(tempstr, "%g", 1)
									nodlist.o(k).label(tempstr)
									sprint(tempstr, "%s", "")
								}
							}

						} else if (k == demyvec.size-1) {
						// if last internode

							if (m == 0) {

								if (nodlist.count) {

									nodnum = 0
									sscanf(nodlist.o(k-1).label, "%lf", &nodnum)

									if (!nodnum) {

										// count relevant segments
										countseg_nod = 0
										countseg_para = 0
										countseg_juxta = 0

										// NaV/Kv7 storage vector
										tempvec = new Vector(2)

										for r = 0, nodlist.o(k-1).size-1 {

											axon[nodlist.o(k-1).x[r]] {

												countseg_nod += nseg

												// store the nodal values (distributed uniformly throughout the node)
												if (r == nodlist.o(k-1).size-1) {

													tempvec.x[0] = gbar_nax
													tempvec.x[1] = gbar_kv7
												}
											}
										}

										axon[intlist.o(k).x[m]] {

											for seg = 1, nseg {
											
												pos = (2*seg-1)/(2*nseg)
												dist_ = getdist(secname(), 0, secname(), pos)

												if (dist_ <= paral) {

													countseg_para += 1
												}

												if (dist_ > paral && dist_ <= paral+juxtal) {

													countseg_juxta += 1
												}
											}
										}

										for r = 0, nodlist.o(k-1).size-1 {

											axon[nodlist.o(k-1).x[r]] {	
													
												// NaV: spreads to para only
												gbar_nax = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
												// Kv7: spreads to para and juxta
												gbar_kv7 = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
											}
										}

										// apply downscaling to internode
										axon[intlist.o(k).x[m]] {

											for seg = 1, nseg {
											
												pos = (2*seg-1)/(2*nseg)
												dist_ = getdist(secname(), 0, secname(), pos)

												if (dist_ <= paral) {

													gbar_nax(pos) = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
													gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
												}

												if (dist_ > paral && dist_ <= paral+juxtal) {

													gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
												}
											}
										}

										// store the downscaling event
										sprint(tempstr, "%g", 1)
										nodlist.o(k-1).label(tempstr)
										sprint(tempstr, "%s", "")

									} else {

										tempvec = new Vector(2)

										for r = 0, nodlist.o(k-1).size-1 {

											axon[nodlist.o(k-1).x[r]] {

												// store the downscaled nodal values
												if (r == nodlist.o(k-1).size-1) {

													tempvec.x[0] = gbar_nax
													tempvec.x[1] = gbar_kv7
												}
											}
										}

										// apply downscaled node to internode
										axon[intlist.o(k).x[m]] {

											for seg = 1, nseg {
											
												pos = (2*seg-1)/(2*nseg)
												dist_ = getdist(secname(), 0, secname(), pos)

												if (dist_ <= paral) {

													gbar_nax(pos) = tempvec.x[0]
													gbar_kv7(pos) = tempvec.x[1]
												}

												if (dist_ > paral && dist_ <= paral+juxtal) {

													gbar_kv7(pos) = tempvec.x[1]
												}
											}
										}
									}
								}
							}

							if (m == intlist.o(k).size-1) {

								if (axbleb_exists) {

									countseg_bleb = 0
									countseg_para = 0
									countseg_juxta = 0

									// NaV/Kv7 storage vector
									tempvec = new Vector(2)

									// axbleblist can only have one vector, because there can only be one bleb
									for r = 0, axbleblist.count-1 {

										forsec axbleblist.o(r).label {

											countseg_bleb += nseg

											// store the nodal values (distributed uniformly throughout the node)
											if (r == axbleblist.count-1) {

												tempvec.x[0] = gbar_nax
												tempvec.x[1] = gbar_kv7
											}
										}
									}

									axon[intlist.o(k).x[m]] {

										for seg = 1, nseg {
										
											pos = (2*seg-1)/(2*nseg)
											dist_ = getdist(secname(), 1, secname(), pos)

											if (dist_ <= paral) {

												countseg_para += 1
											}

											if (dist_ > paral && dist_ <= paral+juxtal) {

												countseg_juxta += 1
											}
										}
									}

									for r = 0, axbleblist.count-1 {

										forsec axbleblist.o(r).label {	
												
											// NaV: spreads to para only
											gbar_nax = (countseg_bleb/(countseg_bleb+countseg_para)) * tempvec.x[0]
											// Kv7: spreads to para and juxta
											gbar_kv7 = (countseg_bleb/(countseg_bleb+countseg_para+countseg_juxta)) * tempvec.x[1]
										}
									}

									// apply downscaling to internode
									axon[intlist.o(k).x[m]] {

										for seg = 1, nseg {
										
											pos = (2*seg-1)/(2*nseg)
											dist_ = getdist(secname(), 1, secname(), pos)

											if (dist_ <= paral) {

												gbar_nax(pos) = (countseg_bleb/(countseg_bleb+countseg_para)) * tempvec.x[0]
												gbar_kv7(pos) = (countseg_bleb/(countseg_bleb+countseg_para+countseg_juxta)) * tempvec.x[1]
											}

											if (dist_ > paral && dist_ <= paral+juxtal) {

												gbar_kv7(pos) = (countseg_bleb/(countseg_bleb+countseg_para+countseg_juxta)) * tempvec.x[1]
											}
										}
									}
								}
							}
						
						} else {
						// if anywhere between first and last internodes

							if (m == 0) {

								if (nodlist.count) {

									nodnum = 0
									sscanf(nodlist.o(k).label, "%lf", &nodnum)

									if (!nodnum) {

										// count relevant segments
										countseg_nod = 0
										countseg_para = 0
										countseg_juxta = 0

										// NaV/Kv7 storage vector
										tempvec = new Vector(2)

										for r = 0, nodlist.o(k).size-1 {

											axon[nodlist.o(k).x[r]] {

												countseg_nod += nseg

												// store the nodal values (distributed uniformly throughout the node)
												if (r == nodlist.o(k).size-1) {

													tempvec.x[0] = gbar_nax
													tempvec.x[1] = gbar_kv7
												}
											}
										}

										axon[intlist.o(k).x[m]] {

											for seg = 1, nseg {
											
												pos = (2*seg-1)/(2*nseg)
												dist_ = getdist(secname(), 0, secname(), pos)

												if (dist_ <= paral) {

													countseg_para += 1
												}

												if (dist_ > paral && dist_ <= paral+juxtal) {

													countseg_juxta += 1
												}
											}
										}

										for r = 0, nodlist.o(k).size-1 {

											axon[nodlist.o(k).x[r]] {	
													
												// NaV: spreads to para only
												gbar_nax = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
												// Kv7: spreads to para and juxta
												gbar_kv7 = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
											}
										}

										// apply downscaling to internode
										axon[intlist.o(k).x[m]] {

											for seg = 1, nseg {
											
												pos = (2*seg-1)/(2*nseg)
												dist_ = getdist(secname(), 0, secname(), pos)

												if (dist_ <= paral) {

													gbar_nax(pos) = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
													gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
												}

												if (dist_ > paral && dist_ <= paral+juxtal) {

													gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
												}
											}
										}

										// store the downscaling event
										sprint(tempstr, "%g", 1)
										nodlist.o(k).label(tempstr)
										sprint(tempstr, "%s", "")

									} else {

										tempvec = new Vector(2)

										for r = 0, nodlist.o(k).size-1 {

											axon[nodlist.o(k).x[r]] {

												// store the downscaled nodal values
												if (r == nodlist.o(k).size-1) {

													tempvec.x[0] = gbar_nax
													tempvec.x[1] = gbar_kv7
												}
											}
										}

										// apply downscaled node to internode
										axon[intlist.o(k).x[m]] {

											for seg = 1, nseg {
											
												pos = (2*seg-1)/(2*nseg)
												dist_ = getdist(secname(), 0, secname(), pos)

												if (dist_ <= paral) {

													gbar_nax(pos) = tempvec.x[0]
													gbar_kv7(pos) = tempvec.x[1]
												}

												if (dist_ > paral && dist_ <= paral+juxtal) {

													gbar_kv7(pos) = tempvec.x[1]
												}
											}
										}
									}
								}
							}

							if (m == intlist.o(k).size-1) {

								if (nodlist.count) {

									countseg_nod = 0
									countseg_para = 0
									countseg_juxta = 0

									// NaV/Kv7 storage vector
									tempvec = new Vector(2)

									for r = 0, nodlist.o(k).size-1 {

										axon[nodlist.o(k).x[r]] {

											countseg_nod += nseg

											// store the nodal values (distributed uniformly throughout the node)
											if (r == nodlist.o(k).size-1) {

												tempvec.x[0] = gbar_nax
												tempvec.x[1] = gbar_kv7
											}
										}
									}									

									axon[intlist.o(k).x[m]] {

										for seg = 1, nseg {
										
											pos = (2*seg-1)/(2*nseg)
											dist_ = getdist(secname(), 1, secname(), pos)

											if (dist_ <= paral) {

												countseg_para += 1
											}

											if (dist_ > paral && dist_ <= paral+juxtal) {

												countseg_juxta += 1
											}
										}
									}

									for r = 0, nodlist.o(k).size-1 {

										axon[nodlist.o(k).x[r]] {	
												
											// NaV: spreads to para only
											gbar_nax = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
											// Kv7: spreads to para and juxta
											gbar_kv7 = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
										}
									}

									// apply downscaling to internode
									axon[intlist.o(k).x[m]] {

										for seg = 1, nseg {
										
											pos = (2*seg-1)/(2*nseg)
											dist_ = getdist(secname(), 1, secname(), pos)

											if (dist_ <= paral) {

												gbar_nax(pos) = (countseg_nod/(countseg_nod+countseg_para)) * tempvec.x[0]
												gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
											}

											if (dist_ > paral && dist_ <= paral+juxtal) {

												gbar_kv7(pos) = (countseg_nod/(countseg_nod+countseg_para+countseg_juxta)) * tempvec.x[1]
											}
										}
									}

									// store the downscaling event
									sprint(tempstr, "%g", 1)
									nodlist.o(k).label(tempstr)
									sprint(tempstr, "%s", "")
								}
							}
						}
					}
				}
			}
		}
	}
}
// --------------------------------------------------------------------------------
