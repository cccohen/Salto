// nFit
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------Variables----------------------------------------
// scale factor for myelin, accounting for the difference in surface area between
// the myelin sheath and axon core. Based on g and ratio entered at setup.
smy = 1/(gr = getvar(ses, "gr.dat"))
// to contain internode numbers (including paranodal sections) requested for demyelination
// by function demyelinate(int1, int2, ..., intn). Each internode number corresponds to the
// same index number in the intlist created by demyelinate().
objref demyvec
leak_dist = 0
paracount = 0
// --------------------------------------------------------------------------------



// --------------------------------setmy-------------------------------------------
// set myelin parameters according to the the myelin scale (smy)
// to account for myelin dimensions (i.e. extra radius over that of the axon core)
// and the extra surface area that affords to the myelin structure to accordingly 
// scale any myelin-specific parameters in axon types involving myelin.
proc setmy() {local k, m, seg, pos, dist_, Kv7_ais_distal

	forsec internodal {

		if (DC || DCPARA) {

			xg[0] *= smy
			xc[0] *= smy

			if (demy) {

				sprint(secstr, "%s", secname())

				for k = 0, demyvec.size-1 {

					for m = 0, intlist.o(demyvec.x[k]).size-1 {

						strdef strint
						sprint(strint, "%s%g%s", ".*[", intlist.o(demyvec.x[k]).x[m], "].*")						
					
						if (issection(strint)) {

							// this will demyelinate the section
							xg[0] = 1/Rext
							xc[0] = 0
							xraxial[0] = rext
							
			// 				// 1st internode, where there is a greater proportion of Kv7 channels in the region of the first paranode and juxtaparanode (Hamada and Kole 2015).
			//				// diffusion of Kv1 from juxtaparanodes into paranodes (Nie et al. 2003)
			// 				// diffusion of NaV from AIS/nodes into at least both paranodes; size of NaV cluster 3x greater in MS demyelinated plaques (Coman et al. 2006).
			// 				// AIS onset moves back by 2 um (from 4 in WT - Hamada et al. 2015).
			// 				// NaV length almost doubles at nodes, Kv7.3 about 1.5 at nodes (Hamada et al. 2015)
			// 				if (demyvec.x[k] == 0) {
								
			// 					if (mode_ == 1) {							
									
			// 						strdef strais
			// 						forsec AIS sprint(strais, "%s", secname())
			// 						leak_dist = ais_length * ((35/23) - 1)
									
			// 						forsec AIS {

			// 							for seg = 1, nseg {

			// 								pos = (2*seg-1)/(2*nseg)											
			// 								Kv7_ais_distal = gbar_kv7(pos)
			// 							}
			// 						}

			// 						forsec secstr {

			// 							for seg = 1, nseg {

			// 								pos = (2*seg-1)/(2*nseg)
			// 								dist_ = getdist(strais, 1, secstr, pos)

			// 								if (dist_ < leak_dist) {

			// 									gbar_kv7(pos) = Kv7_ais_distal
											
			// 								} else {

			// 									// the position is beyond but is within the downstream paranode...
			// 									// take into account Nav and Kv7 leakage from the downstream node into this demyelinated paranode (Hamada and Kole 2015).
			// 									ifsec paranodal {

			// 										gbar_nax = Na_nod_norm * Na_nod_low
			// 										gbar_kv7 = Kv7_nod_norm * Kv7_nod_low
			// 									}												
											// }
										// }
									// }
								// }
							
			// 				} else if (demyvec.x[k] > 0 && demyvec.x[k] < intlist.count-1) {

			// 					if (mode_ == 1) {
									
			// 						// any other internode.
			// 						// there will be only be leakage of Nav and Kv7 into a given paranode if the internode containing that paranode is demyelinated (Hamada and Kole 2015).
			// 						ifsec paranodal {

			// 							gbar_nax = Na_nod_norm * Na_nod_low
			// 							gbar_kv7 = Kv7_nod_norm * Kv7_nod_low
			// 						}
			// 					}
							
			// 				} else if (demyvec.x[k] == intlist.count-1) {

			// 					if (mode_ == 1) {

			// 						if (!axbleb_exists) {

			// 							ifsec paranodal {

			// 								gbar_nax = Na_nod_norm * Na_nod_low
			// 								gbar_kv7 = Kv7_nod_norm * Kv7_nod_low
			// 							}
									
			// 						} else {

			// 							ifsec paranodal {

			// 								paracount += 1

			// 								if (paracount == 1) {

			// 									gbar_nax = Na_nod_norm * Na_nod_low
			// 									gbar_kv7 = Kv7_nod_norm * Kv7_nod_low
											
			// 								} else if (paracount == 2) {

			// 									gbar_nax = Na_end_norm * Na_end_low
			// 									gbar_kv7 = Kv7_end_norm * Kv7_end_low

			// 									paracount = 0
			// 								}
			// 							}
			// 						}
			// 					}
			// 				}
						}
					}
				}
			}
		}
		
		if (SC) {

			g_pas = 1/((Rm_norm * Rm_low) + ((Rmy_norm * Rmy_low)/smy))
			cm = (Cm_norm * Cm_low * Cmy_norm * Cmy_low * smy)/((Cm_norm * Cm_low) + (Cmy_norm * Cmy_low * smy))

			if (per_int_doarg) {
			
				for k = 0, intlist.count-1 {

					for m = 0, intlist.o(k).size-1 {

						axon[intlist.o(k).x[m]] {

							sprint(tempstr, "%s%d%s%d%s", "~g_pas = 1/((Rm_norm * Rm_low) + ((Rmy_", k+1, "_norm * Rmy_", k+1, "_low)/smy))")
							execute(tempstr)

							sprint(tempstr, "%s%d%s%d%s%d%s%d%s", "~cm = (Cm_norm * Cm_low * Cmy_", k+1, "_norm * Cmy_", k+1, "_low * smy)/((Cm_norm * Cm_low) + (Cmy_", k+1, "_norm * Cmy_", k+1, "_low * smy))")
							execute(tempstr)
						}
					}
				}
			}

			if (RmA_doarg) {

				g_pas = 1/((RmA_norm * RmA_low) + ((Rmy_norm * Rmy_low)/smy))
			}

			if (RmI_doarg) {

				g_pas = 1/((RmI_norm * RmI_low) + ((Rmy_norm * Rmy_low)/smy))
			}

			if (exp_doarg) {

				g_pas = 1/((Rm_norm * Rm_low) + (Rm_norm * 20 * Rmy_low)/smy)
				cm = (Cm_norm * Cm_low * (Cm_norm/20) * Cm_low * smy)/((Cm_norm * Cm_low) + ((Cm_norm/20) * Cm_low * smy))
			}			
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc demyelinate() {local i

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter number corresponding to each internode to demyelinate, starting at 1 (separated by commas)."
			print "To discover the number of internodes, try nint(). To demyelinate all internodes, try demyall()."
			stop
		}
	}	

	crintlist()

	demyvec = new Vector()
	
	for i = 1, numarg() {

		demyvec.resize(demyvec.size+1)
		demyvec.x[demyvec.size-1] = $i-1
	}
		
	print "Demyelinating the following internodes:"
	
	for i = 1, numarg() {

		print $i
	}
	
	demy = 1
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc remyelinate() {

	print "Remyelinating all internodes..."	
	
	demy = 0
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc demyall() {

	forsec internodal {

		xg[0] = 1/Rext
		xc[0] = 0
		xraxial[0] = rext		
	}
}
// --------------------------------------------------------------------------------
