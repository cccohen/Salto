// Salto
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------Variables----------------------------------------
objref parambox, paramoptvec, miscbox
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
// initial parameter distribution. see setmy() and setsps()
proc setparam() {local nint, BB, k, m, seg, pos, dist_, inttype

	forall {

		secondorder = order
		celsius = temprec
		
		insert pas 
			e_pas = v_init
	}

	forsec cellular {

		Ra = Ri_norm * Ri_low
		g_pas = 1/(Rm_norm * Rm_low)
		cm = Cm_norm * Cm_low
	}

	forsec praxonal {

		if (DC || DCPARA) {

			insert extracellular

			xraxial[0] = rext
			xg[0] = 1/Rext
			xc[0] = Cext

			e_extracellular = eext
		}

		if (RmA_doarg) {

			g_pas = 1/(RmA_norm * RmA_low)
		}

		if (RiA_doarg) {

			Ra = RiA_norm * RiA_low
		}	
	}

	if (nint = crintlist()) {

		if (DC || DCPARA) {

			for k = 0, nint-1 {

				for m = 0, intlist.o(k).size-1 {

					sscanf(intlist.o(k).label, "%d", &inttype)

					axon[intlist.o(k).x[m]] {

						xraxial[0] = rpa_norm * rpa_low
						xg[0] = 1/(Rmy_norm * Rmy_low)
						xc[0] = Cmy_norm * Cmy_low		

						if (inttype == 4) {				

							if (m == 0) {								

								for seg = 1, nseg {
									
									pos = (2*seg-1)/(2*nseg)
									dist_ = getdist(secname(), 0, secname(), pos)

									if (dist_ <= paral) {

										xraxial[0](pos) *= parafact_norm * parafact_low
									}
								}
							}

							if (m == intlist.o(k).size-1) {

								for seg = 1, nseg {

									pos = (2*seg-1)/(2*nseg)
									dist_ = getdist(secname(), pos, secname(), 1)

									if (dist_ <= paral) {

										xraxial[0](pos) *= parafact_norm * parafact_low
									}
								}
							}
						}
					}
				}
			}
		}		

		if (SC) {

			for k = 0, nint-1 {

				for m = 0, intlist.o(k).size-1 {

					axon[intlist.o(k).x[m]] {
		
						g_pas = 1/((Rm_norm * Rm_low) + (Rmy_norm * Rmy_low))
						cm = (Cm_norm * Cm_low * Cmy_norm * Cmy_low)/((Cm_norm * Cm_low) + (Cmy_norm * Cmy_low))

						if (exp_doarg) {

							g_pas = 1/((Rm_norm * Rm_low) + (Rm_norm * 20 * Rmy_low))
							cm = (Cm_norm * Cm_low * (Cm_norm/20) * Cm_low)/((Cm_norm * Cm_low) + ((Cm_norm/20) * Cm_low))
						}

						if (RmA_doarg) {

							g_pas = 1/((RmA_norm * RmA_low) + (Rmy_norm * Rmy_low))
						}

						if (RmI_doarg) {
							
							g_pas = 1/((RmI_norm * RmI_low) + (Rmy_norm * Rmy_low))
						}

						if (per_int_doarg) {

							sprint(tempstr, "%s%d%s%d%s", "~g_pas = 1/((Rm_norm * Rm_low) + (Rmy_", k+1, "_norm * Rmy_", k+1, "_low))")
							execute(tempstr)

							sprint(tempstr, "%s%d%s%d%s%d%s%d%s", "~cm = (Cm_norm * Cm_low * Cmy_", k+1, "_norm * Cmy_", k+1, "_low)/((Cm_norm * Cm_low) + (Cmy_", k+1, "_norm * Cmy_", k+1, "_low))")
							execute(tempstr)
						}
					}
				}
			}
		}
	}

	if (RmN_doarg) {

		forsec nodal {

			g_pas = 1/(RmN_norm * RmN_low)
		}
	}

	if (!$1 && $2) {

		for BB = 0, BBvec.size-1 {

			forsec piplist.o(BB) {

				Ra = BBvec.x[BB]/(sum_Aj/pipL)
				g_pas = 1/Rpip
				cm = Cpip
			}
		}

		forsec piplist.o(0) {

			cm = Cpip_norm * Cpip_low
		}
	}

	if ($1 == 1) {

		setions()
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// more general than what is allowed under modeltype; maximizes parameter numbers based
// on mode_ and idata only.
func setnp() {local np

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) mode_"
			print "2) idata"
			print "Outputs:"
			print "Number of optimizable parameters for given mode_"
			print "Note: does not change mode_"
			stop
		}
	}	

	np = 0

	if ($1 == 0) {
	
		// start with Ri, Rm, and Cm
		np += 3
		// add Rmy and Cmy if axon is myelinated
		if (axontype > 1 && !per_int_doarg) {

			np += 2

		} else if (axontype > 1 && per_int_doarg) {

			np += 2*intlist.count
		}
		// add rpa if extracellular
		if (axontype > 2) {

			np += 1
		}
		// add parafact, if applicable
		if (axontype == 4) {

			np += 1
		}
		// add Cpip, if applicable (dependent on
		// iclamp data, or idata)
		if ($2) {

			np += 1
		}
		// add RmN, if applicable
		np += RmN_doarg	
		// add RmA, if applicable
		np += RmA_doarg
		// add RmI, if applicable
		np += RmI_doarg		
		// add RiA, if applicable
		np += RiA_doarg		

	} else if ($1 == 1) {
		
		np = setnp(0, 0) + 35

		// juxta
		if (axontype == 4) {

			np += 1
		}
	}	

	return np	
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc setpname() {local k, tempnum

	crveclist(pnamelist, setnp($1, $2))
		
	pnamelist.o(0).label("Ri")
	pnamelist.o(1).label("Rm")
	pnamelist.o(2).label("Cm")

	if (axontype > 1) {

		if (!per_int_doarg) {

			pnamelist.o(3).label("Rmy")
			pnamelist.o(4).label("Cmy")

		} else {

			for k = 0, intlist.count-1 {

				sprint(tempstr, "%s%d", "Rmy_", k+1)
				pnamelist.o(3+2*k).label(tempstr)
				
				sprint(tempstr, "%s%d", "Cmy_", k+1)
				pnamelist.o(3+2*k+1).label(tempstr)
			}
		}
	}

	if (axontype > 2 && !per_int_doarg) {

		pnamelist.o(5).label("rpa")
		
		if (axontype == 4) {

			pnamelist.o(6).label("parafact")
		}
	
	} else if (axontype > 2 && per_int_doarg) {

		pnamelist.o(6+intlist.count-1).label("rpa")
		
		if (axontype == 4) {

			pnamelist.o(6+intlist.count).label("parafact")
		}
	}

	tempnum = setnp(0, $2)
	
	if (RmN_doarg) {

		pnamelist.o(tempnum-2).label("RmN")
	}

	if (RmA_doarg) {

		pnamelist.o(tempnum-2).label("RmA")
	}

	if (RmI_doarg) {

		pnamelist.o(tempnum-2).label("RmI")
	}
	
	if (RmI_doarg && RmN_doarg) {
	
		pnamelist.o(tempnum-3).label("RmI")
		pnamelist.o(tempnum-2).label("RmN")
	}

	if (RiA_doarg) {

		pnamelist.o(tempnum-2).label("RiA")
	}

	if (!$1 && $2) {

		pnamelist.o(tempnum-1).label("Cpip")
	}

	if ($1 == 1) {
		
		tempnum = setnp(0, 0)	
		
		// Genetic parameter selection:
		pnamelist.o(0+tempnum).label("Na_so")
		// dependent on Na_so
		pnamelist.o(1+tempnum).label("lc_Na_de")
		// selected for SOAX
		pnamelist.o(2+tempnum).label("Na_prox")
		// selected for SOAX
		pnamelist.o(3+tempnum).label("Na_ais")
		// selected for SOAX
		pnamelist.o(4+tempnum).label("Na_int")
		// selected for SOAX
		pnamelist.o(5+tempnum).label("Na_nod")
		pnamelist.o(6+tempnum).label("Na_end")
		pnamelist.o(7+tempnum).label("Na_col")
		
		pnamelist.o(8+tempnum).label("Nap_ais")
		pnamelist.o(9+tempnum).label("Nap_int")
		pnamelist.o(10+tempnum).label("Nap_nod")
		pnamelist.o(11+tempnum).label("Nap_end")
		
		pnamelist.o(12+tempnum).label("Kv1_so")
		// dependent on Kv_so and Kv1_so
		pnamelist.o(13+tempnum).label("lc_Kv_Kv1_de")
		// selected for SOAX
		pnamelist.o(14+tempnum).label("Kv1_prox")
		// selected for SOAX
		pnamelist.o(15+tempnum).label("Kv1_ais")
		// selected for SOAX
		pnamelist.o(16+tempnum).label("Kv1_int")
		// selected for SOAX
		pnamelist.o(17+tempnum).label("Kv1_nod")
		pnamelist.o(18+tempnum).label("Kv1_end")
		pnamelist.o(19+tempnum).label("Kv1_col")
		
		pnamelist.o(20+tempnum).label("Kv_so")
		
		pnamelist.o(21+tempnum).label("Kv7_so")
		pnamelist.o(22+tempnum).label("Kv7_de")
		pnamelist.o(23+tempnum).label("Kv7_prox")
		pnamelist.o(24+tempnum).label("Kv7_ais")
		pnamelist.o(25+tempnum).label("Kv7_int")
		pnamelist.o(26+tempnum).label("Kv7_nod")
		pnamelist.o(27+tempnum).label("Kv7_end")
		pnamelist.o(28+tempnum).label("Kv7_col")

		pnamelist.o(29+tempnum).label("KCa")
		
		pnamelist.o(30+tempnum).label("Ca")
		pnamelist.o(31+tempnum).label("It2")

		pnamelist.o(32+tempnum).label("H_so")
		// dependent on H_so
		pnamelist.o(33+tempnum).label("tc_H_de")
		pnamelist.o(34+tempnum).label("H_ax")

		// selected for SOAX
		if (axontype == 4) {

			pnamelist.o(35+tempnum).label("Kv1_juxta")
		}		
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc setpnorm() {
	
	sprint(format, "%s%s", "%s%s%s", maxform)
	sprint(tempstr, format, "~", pnamelist.o($1).label, "_norm=", $2)
	execute(tempstr)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc setparampanel() {local k, height

	if ($2) {
	
		parambox = new VBox(3,1)
		parambox.intercept(1)
		xpanel("", 1)
		xlabel("Non-normalized (display only)")
		xpanel()

		for k = 0, pnamelist.count-1 {
			
			xpanel("", 1)
			xpvalue(pnamelist.o(k).label, &pvec.x[k], 1, "", 0, 1)
			xpanel()
		}
		
		parambox.intercept(0)
		parambox.map("Parameters", 1384.9, 724, 234.24, 288)

	} else {

		parambox = new VBox(3,1)
		parambox.intercept(1)
		xpanel("", 1)
		xlabel("Parameters")
		xpanel()

		for k = 0, pnamelist.count-1 {
			
			xpanel("", 1)
			sprint(commstr, "%s%d%s%d%s%d%s", "updpnorm(pvec.x[", k, "]/plowvec.x[", k, "], ", k, ")")
			xpvalue(pnamelist.o(k).label, &pvec.x[k], 1, commstr, 0, 1)
			xpanel()
		}
		
		parambox.intercept(0)

		if ($1 == 0) {
			height = 288
		} else {
			height = 553.92
		}

		parambox.map("Parameters", 1288, 110, 234.24, height)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc updpnorm() {local p, i

	// if feeding pnorm'vec
	if (argtype(1) == 1) {

		// if feeding a pnorm'vec with known range to update pnormvec with
		// looks like: pnorm'vec, range_low, range_high
		if (numarg() == 3) {

			for p = $2, $3 {

				setpnorm(p, $o1.x[p])
			}

		// update all pnormvec with pnorm'vec
		} else {

			for p = 0, $o1.size-1 {

				setpnorm(p, $o1.x[p])
			}
		}
	
	// feeding a number, or a comma separated list of numbers, that are pnorm's, that must
	// start from the beginning of pnormvec, because that order will be updated.
	} else if (argtype(1) == 0) {

		// the first number corresponds to one pnorm', and the second to the address within pnorm'vec to update
		if (numarg() == 2) {

			setpnorm($2, $1)

		} else {

			for i = 1, numarg() {

				setpnorm(i-1, $i)
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// update non-normalized params p with any pnorm vector
proc updp() {local p

	if (argtype(1) == 1) {

		if (numarg() == 1) {

			for p = 0, $o1.size-1 {

				pvec.x[p] = $o1.x[p] * plowvec.x[p]
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// inserts all ions and sets uniformly distributed ones
// non-uniformly distributed ones are set up in distions
proc setions() {

	forsec apical {

		// non-uniformly distributed
		insert na
		insert kv1
		insert kv
		insert ih
		
		// uniformly distributed
		insert kv7 gbar_kv7 = Kv7_de_norm * Kv7_de_low
		insert kca gbar_kca = KCa_norm * KCa_low
		insert ca gbar_ca = Ca_norm * Ca_low
		insert it2 gbar_it2 = It2_norm * It2_low
	}

	forsec basal {

		// non-uniformly distributed
		insert na
		insert kv1
		insert kv
		insert ih

		// uniformly distributed
		insert kv7 gbar_kv7 = Kv7_de_norm * Kv7_de_low
		insert kca gbar_kca = KCa_norm * KCa_low
		insert ca gbar_ca = Ca_norm * Ca_low
		insert it2 gbar_it2 = It2_norm * It2_low
	}

	forsec somatic {

		insert na gbar_na = Na_so_norm * Na_so_low
		insert kv1 gbar_kv1 = Kv1_so_norm * Kv1_so_low
		insert kv gbar_kv = Kv_so_norm * Kv_so_low
		insert kv7 gbar_kv7 = Kv7_so_norm * Kv7_so_low
		insert kca gbar_kca = KCa_norm * KCa_low
		insert ca gbar_ca = Ca_norm * Ca_low
		insert it2 gbar_it2 = It2_norm * It2_low
		insert ih gbar_ih = H_so_norm * H_so_low
	}

	forsec AIS {

		// sigmoidally distributed
		insert nais
		insert kv1ax
		insert kv7
		
		// uniformly distributed (within each subcompartment)
		insert na
		insert nap
		insert kv1
		insert kv
		insert kca gbar_kca = KCa_norm * KCa_low
		insert ca gbar_ca = Ca_norm * Ca_low				
		insert it2 gbar_it2 = It2_norm * It2_low
		insert ih		
	}

	forsec internodal {		

		// non-uniformly distributed at juxtaparanodes and paranodes (see distions())
		insert kv1ax gbar_kv1ax = Kv1_int_norm * Kv1_int_low
		
		// uniformly distributed except at paranodes (see distions())
		insert nax gbar_nax = Na_int_norm * Na_int_low
		insert nap gbar_nap = Nap_int_norm * Nap_int_low
		insert kv7 gbar_kv7 = Kv7_int_norm * Kv7_int_low
		insert kca gbar_kca = KCa_norm * KCa_low
		insert ca gbar_ca = Ca_norm * Ca_low
		insert it2 gbar_it2 = It2_norm * It2_low
		insert ih gbar_ih = H_ax_norm * H_ax_low
	}	

	forsec nodal {

		insert nax gbar_nax = Na_nod_norm * Na_nod_low
		insert nap gbar_nap = Nap_nod_norm * Nap_nod_low
		insert kv1ax gbar_kv1ax = Kv1_nod_norm * Kv1_nod_low
		insert kv7 gbar_kv7 = Kv7_nod_norm * Kv7_nod_low
		insert kca gbar_kca = KCa_norm * KCa_low
		insert ca gbar_ca = Ca_norm * Ca_low
		insert it2 gbar_it2 = It2_norm * It2_low
		insert ih gbar_ih = H_ax_norm * H_ax_low
	}

	if (axbleb_exists) {

		forsec axbleb {

			insert nax gbar_nax = Na_end_norm * Na_end_low
			insert nap gbar_nap = Nap_end_norm * Nap_end_low
			insert kv1ax gbar_kv1ax = Kv1_end_norm * Kv1_end_low
			insert kv7 gbar_kv7 = Kv7_end_norm * Kv7_end_low
			insert kca gbar_kca = KCa_norm * KCa_low
			insert ca gbar_ca = Ca_norm * Ca_low
			insert it2 gbar_it2 = It2_norm * It2_low
			insert ih gbar_ih = H_ax_norm * H_ax_low
		}
	}

	forsec collateral {

		insert nax gbar_nax = Na_col_norm * Na_col_low
		insert kv1ax gbar_kv1ax = Kv1_col_norm * Kv1_col_low
		insert kv7 gbar_kv7 = Kv7_col_norm * Kv7_col_low
		insert kca gbar_kca = KCa_norm * KCa_low
		insert ca gbar_ca = Ca_norm * Ca_low
		insert it2 gbar_it2 = It2_norm * It2_low
		insert ih gbar_ih = H_ax_norm * H_ax_low
	}

	// cell-wide ionic mechanisms and constants
	forsec cellular {

		ena = 55
		ek = -85
		eh = -45
		eca = 140
		ion_style("ca_ion",0,1,0,0,0)

		// Layer 5 LVA Ca constants
		vh1_it2 = 56
		vh2_it2 = 415
		ah_it2 = 30
		v12m_it2 = 45
		v12h_it2 = 65
		am_it2 = 3
		vm1_it2 = 50
		vm2_it2 = 125

		// Ca-sensitivity of KCa channel
		caix_kca = 0.7
		// activation rate KCa
		Ra_kca = 1
		// inactivation rate KCa
		Rb_kca = 2.5
		// calcium extrusion rate, in ms
		taur_cad = 80
	}
	
	distions()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// Distance-dependent distributions for dendritic Ih (Kole et al 2006), Na, Kv 
// and Kv1 (Keren et al., 2009, JPhysiol and Stuart, Schiller and Sakmann, 1997).
// built with section numbers that (roughly) increase from the soma out.
proc distions() {local seg, pos, dist_, nint, k, m, inttype localobj tempvec

	forsec apical {

		for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			dist_ = getdist("soma", 0.5, secname(), pos)

			gbar_na(pos) = (Na_so_norm * Na_so_low) * exp(-dist_/(lc_Na_de_norm * lc_Na_de_low))
			
			gbar_kv1(pos) = (Kv1_so_norm * Kv1_so_low) * exp(-dist_/(lc_Kv_Kv1_de_norm * lc_Kv_Kv1_de_low))
			gbar_kv(pos) = (Kv_so_norm * Kv_so_low) * exp(-dist_/(lc_Kv_Kv1_de_norm * lc_Kv_Kv1_de_low))
			
			gbar_ih(pos) = H_so_norm * H_so_low * exp(tc_H_de_norm * tc_H_de_low * dist_)
		}
	}

	forsec basal {
		
		for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			dist_ = getdist("soma", 0.5, secname(), pos)

			gbar_na(pos) = (Na_so_norm * Na_so_low) * exp(-dist_/(lc_Na_de_norm * lc_Na_de_low))
			
			gbar_kv1(pos) = (Kv1_so_norm * Kv1_so_low) * exp(-dist_/(lc_Kv_Kv1_de_norm * lc_Kv_Kv1_de_low))
			gbar_kv(pos) = (Kv_so_norm * Kv_so_low) * exp(-dist_/(lc_Kv_Kv1_de_norm * lc_Kv_Kv1_de_low))
			
			gbar_ih(pos) = H_so_norm * H_so_low * exp(tc_H_de_norm * tc_H_de_low * dist_)
		}
	}

	forsec AIS {

		for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			dist_ = getdist(aislist.o(0).label, 0, secname(), pos)

			// preAIS, border dependent, dependent upon preAIS border percentage (defparam)
			if (dist_ < preAIS_border) {

				gbar_nais(pos) = 0
				gbar_nap(pos) = 0
				gbar_kv1ax(pos) = 0
					
				gbar_na(pos) = (Na_so_norm * Na_so_low) * exp(-dist_/lc_Na_de)
				
				gbar_kv1(pos) = (Kv1_so_norm * Kv1_so_low) * exp(-dist_/lc_Kv_Kv1_de)
				gbar_kv(pos) = (Kv_so_norm * Kv_so_low) * exp(-dist_/lc_Kv_Kv1_de)
			
				gbar_ih(pos) = H_so_norm * H_so_low * exp(tc_H_de_norm * tc_H_de_low * dist_)

				gbar_kv7(pos) = Kv7_de_norm * Kv7_de_low

			} else {

				gbar_na(pos) = 0
				gbar_kv1(pos) = 0
				gbar_kv(pos) = 0
				gbar_ih(pos) = H_ax_norm * H_ax_low
				gbar_nap(pos) = Nap_ais_norm * Nap_ais_low

				if (dist_ < Nais_midpoint) {

					gbar_nais(pos) = Na_prox_norm * Na_prox_low + (Na_ais_norm * Na_ais_low - Na_prox_norm * Na_prox_low)*(a_nais_Gaussian*exp((-(dist_- b_nais_Gaussian)^2)/(2*c_nais_Gaussian^2)))
				
				} else {

					gbar_nais(pos) = ((Na_ais_norm * Na_ais_low)/2) * (1 + (a_nais_Gaussian*exp((-(dist_- b_nais_Gaussian)^2)/(2*c_nais_Gaussian^2))))
				}
				
				gbar_kv1ax(pos) = Kv1_prox_norm * Kv1_prox_low + (Kv1_ais_norm * Kv1_ais_low - Kv1_prox_norm * Kv1_prox_low)/(1 + exp(-0.6 * (dist_ - Kv1_ais_midpoint)))
				gbar_kv7(pos) = Kv7_prox_norm * Kv7_prox_low + (Kv7_ais_norm * Kv7_ais_low - Kv7_prox_norm * Kv7_prox_low)/(1 + exp(-dist_ + Kv7_ais_midpoint)^(1/5))
			}
		}
	}

	if (DCPARA) {

		for k = 0, nint-1 {

			sscanf(intlist.o(k).label, "%d", &inttype)

			if (inttype == 4) {

				for m = 0, intlist.o(k).size-1 {

					axon[intlist.o(k).x[m]] {					

						if (m == 0) {

							for seg = 1, nseg {

								pos = (2*seg-1)/(2*nseg)
								dist_ = getdist(secname(), 0, secname(), pos)

								if (dist_ <= paral) {

									gbar_nax(pos) = 0
									gbar_nap(pos) = 0
									gbar_kv1ax(pos) = 0
									gbar_kv7(pos) = 0
									gbar_kca(pos) = 0
									gbar_ca(pos) = 0
									gbar_it2(pos) = 0
									gbar_ih(pos) = 0
								}

								if (dist_ > paral && dist_ <= paral+juxtal) {

									gbar_kv1ax(pos) = Kv1_juxta_norm * Kv1_juxta_low
								}
							}
						}

						if (m == intlist.o(k).size-1) {

							for seg = 1, nseg {

								pos = (2*seg-1)/(2*nseg)
								dist_ = getdist(secname(), 1, secname(), pos)

								if (dist_ <= paral+juxtal && dist_ > paral) {

									gbar_kv1ax(pos) = Kv1_juxta_norm * Kv1_juxta_low
								}				

								if (dist_ <= paral) {

									gbar_nax(pos) = 0
									gbar_nap(pos) = 0
									gbar_kv1ax(pos) = 0
									gbar_kv7(pos) = 0
									gbar_kca(pos) = 0
									gbar_ca(pos) = 0
									gbar_it2(pos) = 0
									gbar_ih(pos) = 0
								}
							}
						}
					}
				}
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc print_modeltype() {

	if (numarg() == 3 && argtype(3) == 0) {

		if ($3) {

			print reclocstr
		}
	}
	
	print "Model type: ", modeltypestr
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getmodeltype() {local rec, SOf, AXf, DEf

	sprint(modeltypestr, "%s", "")
	sprint(reclocstr, "%s", "")
	DEFAULT = 0

	// count locations
	SOf = 0
	AXf = 0
	DEf = 0

	sprint(SOstr, "%s", "soma")
	sprint(AXstr, "%s", "axon")
	sprint(DEstr, "%s", "dend")
	sprint(APstr, "%s", "apic")

	// define number and location of recordings
	if (nrec) {

		for rec = 0, nrec-1 {

			if (strf.substr(recloclist.o(rec).label, SOstr) > -1) {
			
				SOf += 1
			
			} else if (strf.substr(recloclist.o(rec).label, AXstr) > -1) {
			
				AXf += 1
			
			} else if ((strf.substr(recloclist.o(rec).label, DEstr) > -1) || (strf.substr(recloclist.o(rec).label, APstr) > -1)) {

				DEf += 1
			}
		}
	}

	// labels for combination of fit variables
	SOAX = 0
	SODE = 0
	SO = 0
	AX = 0
	DE = 0

	// Establish model type as a function of fit variable locations
	if (SOf > 0 && AXf > 0 && DEf == 0) {

		SOAX = 1
		modeltypestr = "SOAX"

		if ($1 == 0) {

			Ri_doarg = 1
			Ri_uselog = 1

			Rm_doarg = 1
			Rm_uselog = 1

			Cm_doarg = 1
			Cm_uselog = 1

			Cpip_doarg = 1
			Cpip_uselog = 1

			if (axontype > 1) {

				Rmy_doarg = 1
				Rmy_uselog = 1
				
				Cmy_doarg = 1
				Cmy_uselog = 1

				if (axontype > 2) {

					rpa_doarg = 1
					rpa_uselog = 1

					if (axontype == 4) {

						parafact_doarg = 1
						parafact_uselog = 1
					}
				}
			
			} else {

				Rmy_doarg = 0
				Rmy_uselog = 0
				
				Cmy_doarg = 0
				Cmy_uselog = 0

				rpa_doarg = 0
				rpa_uselog = 0

				parafact_doarg = 0
				parafact_uselog = 0
			}

			
			Na_so_doarg = 0
			Na_so_uselog = 0

			lc_Na_de_doarg = 0
			lc_Na_de_uselog = 0

			Na_prox_doarg = 0
			Na_prox_uselog = 0

			Na_ais_doarg = 0
			Na_ais_uselog = 0

			Na_int_doarg = 0
			Na_int_uselog = 0

			Na_nod_doarg = 0
			Na_nod_uselog = 0

			Na_end_doarg = 0
			Na_end_uselog = 0

			Na_col_doarg = 0
			Na_col_uselog = 0


			Nap_ais_doarg = 0
			Nap_ais_uselog = 0

			Nap_int_doarg = 0
			Nap_int_uselog = 0

			Nap_nod_doarg = 0
			Nap_nod_uselog = 0

			Nap_end_doarg = 0
			Nap_end_uselog = 0


			Kv1_so_doarg = 0
			Kv1_so_uselog = 0

			lc_Kv_Kv1_de_doarg = 0
			lc_Kv_Kv1_de_uselog = 0

			Kv1_prox_doarg = 0
			Kv1_prox_uselog = 0

			Kv1_ais_doarg = 0
			Kv1_ais_uselog = 0

			Kv1_int_doarg = 0
			Kv1_int_uselog = 0

			Kv1_nod_doarg = 0
			Kv1_nod_uselog = 0

			Kv1_end_doarg = 0
			Kv1_end_uselog = 0

			Kv1_col_doarg = 0
			Kv1_col_uselog = 0


			Kv_so_doarg = 0
			Kv_so_uselog = 0


			Kv7_de_doarg = 0
			Kv7_de_uselog = 0

			Kv7_so_doarg = 0
			Kv7_so_uselog = 0

			Kv7_prox_doarg = 0
			Kv7_prox_uselog = 0

			Kv7_ais_doarg = 0
			Kv7_ais_uselog = 0

			Kv7_int_doarg = 0
			Kv7_int_uselog = 0

			Kv7_nod_doarg = 0
			Kv7_nod_uselog = 0

			Kv7_end_doarg = 0
			Kv7_end_uselog = 0

			Kv7_col_doarg = 0
			Kv7_col_uselog = 0


			KCa_doarg = 0
			KCa_uselog = 0


			Ca_doarg = 0
			Ca_uselog = 0

			It2_doarg = 0
			It2_uselog = 0


			H_so_doarg = 0
			H_so_uselog = 0

			tc_H_de_doarg = 0
			tc_H_de_uselog = 0

			H_ax_doarg = 0
			H_ax_uselog = 0


			Kv1_juxta_doarg = 0
			Kv1_juxta_uselog = 0
		}

		if ($1 == 1) {

			Ri_doarg = 0
			Ri_uselog = 0
			
			rpa_doarg = 0
			rpa_uselog = 0
			
			parafact_doarg = 0
			parafact_uselog = 0
			
			Rm_doarg = 0
			Rm_uselog = 0

			Rmy_doarg = 0
			Rmy_uselog = 0
			
			Cm_doarg = 0
			Cm_uselog = 0
			
			Cmy_doarg = 0
			Cmy_uselog = 0
			
			Cpip_doarg = 0
			Cpip_uselog = 0

			
			Na_so_doarg = 1
			Na_so_uselog = 1

			lc_Na_de_doarg = 1
			lc_Na_de_uselog = 1

			Na_prox_doarg = 1
			Na_prox_uselog = 1

			Na_ais_doarg = 1
			Na_ais_uselog = 1

			Na_int_doarg = 1
			Na_int_uselog = 1

			Na_nod_doarg = 1
			Na_nod_uselog = 1

			Na_end_doarg = 1
			Na_end_uselog = 1

			Na_col_doarg = 1
			Na_col_uselog = 1


			Nap_ais_doarg = 1
			Nap_ais_uselog = 1

			Nap_int_doarg = 1
			Nap_int_uselog = 1

			Nap_nod_doarg = 1
			Nap_nod_uselog = 1

			Nap_end_doarg = 1
			Nap_end_uselog = 1


			Kv1_so_doarg = 1
			Kv1_so_uselog = 1

			lc_Kv_Kv1_de_doarg = 1
			lc_Kv_Kv1_de_uselog = 1

			Kv1_prox_doarg = 1
			Kv1_prox_uselog = 1

			Kv1_ais_doarg = 1
			Kv1_ais_uselog = 1

			Kv1_int_doarg = 1
			Kv1_int_uselog = 1

			Kv1_nod_doarg = 1
			Kv1_nod_uselog = 1

			Kv1_end_doarg = 1
			Kv1_end_uselog = 1

			Kv1_col_doarg = 1
			Kv1_col_uselog = 1


			Kv_so_doarg = 1
			Kv_so_uselog = 1


			Kv7_de_doarg = 1
			Kv7_de_uselog = 1

			Kv7_so_doarg = 1
			Kv7_so_uselog = 1

			Kv7_prox_doarg = 1
			Kv7_prox_uselog = 1

			Kv7_ais_doarg = 1
			Kv7_ais_uselog = 1

			Kv7_int_doarg = 1
			Kv7_int_uselog = 1

			Kv7_nod_doarg = 1
			Kv7_nod_uselog = 1

			Kv7_end_doarg = 1
			Kv7_end_uselog = 1

			Kv7_col_doarg = 1
			Kv7_col_uselog = 1


			KCa_doarg = 1
			KCa_uselog = 1


			Ca_doarg = 1
			Ca_uselog = 1

			It2_doarg = 1
			It2_uselog = 1


			H_so_doarg = 1
			H_so_uselog = 1

			tc_H_de_doarg = 1
			tc_H_de_uselog = 1

			H_ax_doarg = 1
			H_ax_uselog = 1

			if (axontype == 4) {

				Kv1_juxta_doarg = 1
				Kv1_juxta_uselog = 1
			}
		}

		sprint(reclocstr, "%d%s%d%s", SOf, " somatic and ", AXf, " axonal recording locations found")
	}

	if (SOf > 0 && DEf > 0 && AXf == 0) {

		SODE = 1
		modeltypestr = "SODE"

		if ($1 == 0) {

			Ri_doarg = 1
			Ri_uselog = 1
			
			rpa_doarg = 0
			rpa_uselog = 0
			
			parafact_doarg = 0
			parafact_uselog = 0
			
			Rm_doarg = 1
			Rm_uselog = 1

			Rmy_doarg = 0
			Rmy_uselog = 0
			
			Cm_doarg = 1
			Cm_uselog = 1
			
			Cmy_doarg = 0
			Cmy_uselog = 0
			
			Cpip_doarg = 1
			Cpip_uselog = 1

			
			Na_so_doarg = 0
			Na_so_uselog = 0

			lc_Na_de_doarg = 0
			lc_Na_de_uselog = 0

			Na_prox_doarg = 0
			Na_prox_uselog = 0

			Na_ais_doarg = 0
			Na_ais_uselog = 0

			Na_int_doarg = 0
			Na_int_uselog = 0

			Na_nod_doarg = 0
			Na_nod_uselog = 0

			Na_end_doarg = 0
			Na_end_uselog = 0

			Na_col_doarg = 0
			Na_col_uselog = 0


			Nap_ais_doarg = 0
			Nap_ais_uselog = 0

			Nap_int_doarg = 0
			Nap_int_uselog = 0

			Nap_nod_doarg = 0
			Nap_nod_uselog = 0

			Nap_end_doarg = 0
			Nap_end_uselog = 0


			Kv1_so_doarg = 0
			Kv1_so_uselog = 0

			lc_Kv_Kv1_de_doarg = 0
			lc_Kv_Kv1_de_uselog = 0

			Kv1_prox_doarg = 0
			Kv1_prox_uselog = 0

			Kv1_ais_doarg = 0
			Kv1_ais_uselog = 0

			Kv1_int_doarg = 0
			Kv1_int_uselog = 0

			Kv1_nod_doarg = 0
			Kv1_nod_uselog = 0

			Kv1_end_doarg = 0
			Kv1_end_uselog = 0

			Kv1_col_doarg = 0
			Kv1_col_uselog = 0


			Kv_so_doarg = 0
			Kv_so_uselog = 0


			Kv7_de_doarg = 0
			Kv7_de_uselog = 0

			Kv7_so_doarg = 0
			Kv7_so_uselog = 0

			Kv7_prox_doarg = 0
			Kv7_prox_uselog = 0

			Kv7_ais_doarg = 0
			Kv7_ais_uselog = 0

			Kv7_int_doarg = 0
			Kv7_int_uselog = 0

			Kv7_nod_doarg = 0
			Kv7_nod_uselog = 0

			Kv7_end_doarg = 0
			Kv7_end_uselog = 0

			Kv7_col_doarg = 0
			Kv7_col_uselog = 0


			KCa_doarg = 0
			KCa_uselog = 0


			Ca_doarg = 0
			Ca_uselog = 0

			It2_doarg = 0
			It2_uselog = 0


			H_so_doarg = 0
			H_so_uselog = 0

			tc_H_de_doarg = 0
			tc_H_de_uselog = 0

			H_ax_doarg = 0
			H_ax_uselog = 0


			Kv1_juxta_doarg = 0
			Kv1_juxta_uselog = 0
		}

		if ($1 == 1) {

			Ri_doarg = 0
			Ri_uselog = 0
			
			rpa_doarg = 0
			rpa_uselog = 0
			
			parafact_doarg = 0
			parafact_uselog = 0
			
			Rm_doarg = 0
			Rm_uselog = 0

			Rmy_doarg = 0
			Rmy_uselog = 0
			
			Cm_doarg = 0
			Cm_uselog = 0
			
			Cmy_doarg = 0
			Cmy_uselog = 0
			
			Cpip_doarg = 0
			Cpip_uselog = 0

			
			Na_so_doarg = 1
			Na_so_uselog = 1

			lc_Na_de_doarg = 1
			lc_Na_de_uselog = 1

			Na_prox_doarg = 1
			Na_prox_uselog = 1

			Na_ais_doarg = 1
			Na_ais_uselog = 1

			Na_int_doarg = 0
			Na_int_uselog = 0

			Na_nod_doarg = 0
			Na_nod_uselog = 0

			Na_end_doarg = 0
			Na_end_uselog = 0

			Na_col_doarg = 0
			Na_col_uselog = 0


			Nap_ais_doarg = 1
			Nap_ais_uselog = 1

			Nap_int_doarg = 0
			Nap_int_uselog = 0

			Nap_nod_doarg = 0
			Nap_nod_uselog = 0

			Nap_end_doarg = 0
			Nap_end_uselog = 0


			Kv1_so_doarg = 1
			Kv1_so_uselog = 1

			lc_Kv_Kv1_de_doarg = 1
			lc_Kv_Kv1_de_uselog = 1

			Kv1_prox_doarg = 1
			Kv1_prox_uselog = 1

			Kv1_ais_doarg = 1
			Kv1_ais_uselog = 1

			Kv1_int_doarg = 0
			Kv1_int_uselog = 0

			Kv1_nod_doarg = 0
			Kv1_nod_uselog = 0

			Kv1_end_doarg = 0
			Kv1_end_uselog = 0

			Kv1_col_doarg = 0
			Kv1_col_uselog = 0


			Kv_so_doarg = 1
			Kv_so_uselog = 1


			Kv7_de_doarg = 1
			Kv7_de_uselog = 1

			Kv7_so_doarg = 1
			Kv7_so_uselog = 1

			Kv7_prox_doarg = 1
			Kv7_prox_uselog = 1

			Kv7_ais_doarg = 1
			Kv7_ais_uselog = 1

			Kv7_int_doarg = 0
			Kv7_int_uselog = 0

			Kv7_nod_doarg = 0
			Kv7_nod_uselog = 0

			Kv7_end_doarg = 0
			Kv7_end_uselog = 0

			Kv7_col_doarg = 0
			Kv7_col_uselog = 0


			KCa_doarg = 1
			KCa_uselog = 1


			Ca_doarg = 1
			Ca_uselog = 1

			It2_doarg = 1
			It2_uselog = 1


			H_so_doarg = 1
			H_so_uselog = 1

			tc_H_de_doarg = 1
			tc_H_de_uselog = 1

			H_ax_doarg = 0
			H_ax_uselog = 0

			Kv1_juxta_doarg = 0
			Kv1_juxta_uselog = 0
		}
		
		sprint(reclocstr, "%d%s%d%s", SOf, " somatic and ", DEf, " dendritic recording locations found")
	}

	if (SOf > 0 && AXf == 0 && DEf == 0) {

		SO = 1
		modeltypestr = "SO"

		if ($1 == 0) {

			Ri_doarg = 1
			Ri_uselog = 1
			
			rpa_doarg = 0
			rpa_uselog = 0
			
			parafact_doarg = 0
			parafact_uselog = 0
			
			Rm_doarg = 1
			Rm_uselog = 1

			Rmy_doarg = 0
			Rmy_uselog = 0
			
			Cm_doarg = 1
			Cm_uselog = 1
			
			Cmy_doarg = 0
			Cmy_uselog = 0
			
			Cpip_doarg = 1
			Cpip_uselog = 1

			
			Na_so_doarg = 0
			Na_so_uselog = 0

			lc_Na_de_doarg = 0
			lc_Na_de_uselog = 0

			Na_prox_doarg = 0
			Na_prox_uselog = 0

			Na_ais_doarg = 0
			Na_ais_uselog = 0

			Na_int_doarg = 0
			Na_int_uselog = 0

			Na_nod_doarg = 0
			Na_nod_uselog = 0

			Na_end_doarg = 0
			Na_end_uselog = 0

			Na_col_doarg = 0
			Na_col_uselog = 0


			Nap_ais_doarg = 0
			Nap_ais_uselog = 0

			Nap_int_doarg = 0
			Nap_int_uselog = 0

			Nap_nod_doarg = 0
			Nap_nod_uselog = 0

			Nap_end_doarg = 0
			Nap_end_uselog = 0


			Kv1_so_doarg = 0
			Kv1_so_uselog = 0

			lc_Kv_Kv1_de_doarg = 0
			lc_Kv_Kv1_de_uselog = 0

			Kv1_prox_doarg = 0
			Kv1_prox_uselog = 0

			Kv1_ais_doarg = 0
			Kv1_ais_uselog = 0

			Kv1_int_doarg = 0
			Kv1_int_uselog = 0

			Kv1_nod_doarg = 0
			Kv1_nod_uselog = 0

			Kv1_end_doarg = 0
			Kv1_end_uselog = 0

			Kv1_col_doarg = 0
			Kv1_col_uselog = 0


			Kv_so_doarg = 0
			Kv_so_uselog = 0


			Kv7_de_doarg = 0
			Kv7_de_uselog = 0

			Kv7_so_doarg = 0
			Kv7_so_uselog = 0

			Kv7_prox_doarg = 0
			Kv7_prox_uselog = 0

			Kv7_ais_doarg = 0
			Kv7_ais_uselog = 0

			Kv7_int_doarg = 0
			Kv7_int_uselog = 0

			Kv7_nod_doarg = 0
			Kv7_nod_uselog = 0

			Kv7_end_doarg = 0
			Kv7_end_uselog = 0

			Kv7_col_doarg = 0
			Kv7_col_uselog = 0


			KCa_doarg = 0
			KCa_uselog = 0


			Ca_doarg = 0
			Ca_uselog = 0

			It2_doarg = 0
			It2_uselog = 0


			H_so_doarg = 0
			H_so_uselog = 0

			tc_H_de_doarg = 0
			tc_H_de_uselog = 0

			H_ax_doarg = 0
			H_ax_uselog = 0


			Kv1_juxta_doarg = 0
			Kv1_juxta_uselog = 0
		}

		if ($1 == 1) {

			Ri_doarg = 0
			Ri_uselog = 0
			
			rpa_doarg = 0
			rpa_uselog = 0
			
			parafact_doarg = 0
			parafact_uselog = 0
			
			Rm_doarg = 0
			Rm_uselog = 0

			Rmy_doarg = 0
			Rmy_uselog = 0
			
			Cm_doarg = 0
			Cm_uselog = 0
			
			Cmy_doarg = 0
			Cmy_uselog = 0
			
			Cpip_doarg = 0
			Cpip_uselog = 0

			
			Na_so_doarg = 1
			Na_so_uselog = 1

			lc_Na_de_doarg = 1
			lc_Na_de_uselog = 1

			Na_prox_doarg = 1
			Na_prox_uselog = 1

			Na_ais_doarg = 1
			Na_ais_uselog = 1

			Na_int_doarg = 0
			Na_int_uselog = 0

			Na_nod_doarg = 0
			Na_nod_uselog = 0

			Na_end_doarg = 0
			Na_end_uselog = 0

			Na_col_doarg = 0
			Na_col_uselog = 0


			Nap_ais_doarg = 1
			Nap_ais_uselog = 1

			Nap_int_doarg = 0
			Nap_int_uselog = 0

			Nap_nod_doarg = 0
			Nap_nod_uselog = 0

			Nap_end_doarg = 0
			Nap_end_uselog = 0


			Kv1_so_doarg = 1
			Kv1_so_uselog = 1

			lc_Kv_Kv1_de_doarg = 1
			lc_Kv_Kv1_de_uselog = 1

			Kv1_prox_doarg = 1
			Kv1_prox_uselog = 1

			Kv1_ais_doarg = 1
			Kv1_ais_uselog = 1

			Kv1_int_doarg = 0
			Kv1_int_uselog = 0

			Kv1_nod_doarg = 0
			Kv1_nod_uselog = 0

			Kv1_end_doarg = 0
			Kv1_end_uselog = 0

			Kv1_col_doarg = 0
			Kv1_col_uselog = 0


			Kv_so_doarg = 1
			Kv_so_uselog = 1


			Kv7_de_doarg = 1
			Kv7_de_uselog = 1

			Kv7_so_doarg = 1
			Kv7_so_uselog = 1

			Kv7_prox_doarg = 1
			Kv7_prox_uselog = 1

			Kv7_ais_doarg = 1
			Kv7_ais_uselog = 1

			Kv7_int_doarg = 0
			Kv7_int_uselog = 0

			Kv7_nod_doarg = 0
			Kv7_nod_uselog = 0

			Kv7_end_doarg = 0
			Kv7_end_uselog = 0

			Kv7_col_doarg = 0
			Kv7_col_uselog = 0


			KCa_doarg = 1
			KCa_uselog = 1


			Ca_doarg = 1
			Ca_uselog = 1

			It2_doarg = 1
			It2_uselog = 1


			H_so_doarg = 1
			H_so_uselog = 1

			tc_H_de_doarg = 1
			tc_H_de_uselog = 1

			H_ax_doarg = 0
			H_ax_uselog = 0

			Kv1_juxta_doarg = 0
			Kv1_juxta_uselog = 0
		}

		sprint(reclocstr, "%d%s", SOf, " somatic recording location(s) found")
	}

	if (SOf == 0 && AXf == 0 && DEf == 0) {

		DEFAULT = 1
		modeltypestr = "DEFAULT"

		sprint(reclocstr, "%s", "No recording locations found")
	}

	if ($1 == 0) {

		sprint(modeltypestr, "%s%s%s", "pas", "-", modeltypestr)
	}

	if ($1 == 1) {

		sprint(modeltypestr, "%s%s%s", "act", "-", modeltypestr)
	}

	if (!Ri_doarg) {

		// Cohen et al. 2020
		Ri_def = 1.5464819841E+02
	}

	if (!Rm_doarg) {

		// Cohen et al. 2020
		Rm_def = 2.4603614141E+04
	}

	if (!Cm_doarg) {

		// Cohen et al. 2020
		Cm_def = 1.1478965068E+00
	}

	if (!Cpip_doarg) {

		// Cohen et al. 2020
		Cpip_def = 5.5195171802E-05
	}

	if (DCPARA) {

		if (!Rmy_doarg) {

			// Cohen et al. 2020
			Rmy_def = 2.3965099892E+05
		}

		if (!Cmy_doarg) {

			// Cohen et al. 2020
			Cmy_def = 3.7906668425E-02
		}

		if (!rpa_doarg) {

			// Cohen et al. 2020
			rpa_def = 1.2494013007E+05
		}

		if (!parafact_doarg) {

			parafact_def = 1.8152775323E+01
		}
	}

	if (DC) {

		if (!Rmy_doarg) {

			// Cohen et al. 2020
			Rmy_def = 7.8320037656E+04
		}

		if (!Cmy_doarg) {

			// Cohen et al. 2020
			Cmy_def = 1.6947461000E-02
		}

		if (!rpa_doarg) {

			// Cohen et al. 2020
			rpa_def = 5.0560001429E+05
		}
	}

	// to modify from defaults, and take into account extra parameters, if any.
	loadfile(1, ses, doargfilestr)
	// update parameter initializations
	defparam()

	if (RmN_doarg) {

		sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RmN")
	}
	
	if (RmA_doarg) {

		sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RmA")
	}

	if (RmI_doarg) {

		sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RmI")
	}

	if (RiA_doarg) {

		sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RiA")
	}

	if (per_int_doarg) {
	
		sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "perint")
		initperint()
	}

	setpname($1, $2)
	// update the p-vectors
	getpdef()
	getp()
	getpnormdef()
	getpnorm()
	getplow()
	getphi()
	getdoarg()
	getuselog()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc initpvecs() {

	pdefvec = new Vector()
	pvec = new Vector()
	pnormdefvec = new Vector()
	pnormvec = new Vector()
	plowvec = new Vector()
	phivec = new Vector()
	doargvec = new Vector()
	uselogvec = new Vector()
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
proc getpdef() {local k

	if (!pdefvec.size) {

		for k = 0, pnamelist.count-1 {
			
			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_def")
			execute(tempstr)

			pdefvec.resize(pdefvec.size+1)
			pdefvec.x[pdefvec.size-1] = num
		}
	
	} else {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_def")
			execute(tempstr)
			
			pdefvec.x[k] = num
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// gets current p (parameters) in pvec
proc getp() {local k

	if (!pvec.size) {

		for k = 0, pnamelist.count-1 {
			
			sprint(tempstr, "%s%s", "num = ", pnamelist.o(k).label)
			execute(tempstr)

			pvec.resize(pvec.size+1)
			pvec.x[pvec.size-1] = num
		}

	} else {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s", "num = ", pnamelist.o(k).label)
			execute(tempstr)
			
			pvec.x[k] = num
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// gets current pnormdef in pnormdefvec
proc getpnormdef() {local k

	if (!pnormdefvec.size) {

		for k = 0, pnamelist.count-1 {
			
			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_norm_def")
			execute(tempstr)

			pnormdefvec.resize(pnormdefvec.size+1)
			pnormdefvec.x[pnormdefvec.size-1] = num
		}
	
	} else {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_norm_def")
			execute(tempstr)

			pnormdefvec.x[k] = num
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getpnorm() {local k

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Takes no arguments. Gets/updates current pnorm (_norm, AKA RunFitParm variables) in pnormvec."
			print "Note: pnormvec does not track current pnorm, but what should be those sent for optimization."
			stop
		}
	}

	if (!numarg()) {

		if (!pnormvec.size) {
		
			for k = 0, pnamelist.count-1 {
				
				sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_norm")
				execute(tempstr)

				pnormvec.resize(pnormvec.size+1)
				pnormvec.x[pnormvec.size-1] = num
			}

		} else {

			for k = 0, pnamelist.count-1 {

				sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_norm")
				execute(tempstr)

				pnormvec.x[k] = num
			}
		}
	}

	if (numarg() == 2 && argtype(1) == 0 && argtype(2) == 0) {

		pnormvec.x[$1] = $2
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// gets current plow in plowvec
proc getplow() {local k

	if (!plowvec.size) {

		for k = 0, pnamelist.count-1 {
			
			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_low")
			execute(tempstr)

			plowvec.resize(plowvec.size+1)
			plowvec.x[plowvec.size-1] = num
		}
	
	} else {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_low")
			execute(tempstr)

			plowvec.x[k] = num
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// gets current phi in phivec
proc getphi() {local k

	if (!phivec.size) {

		for k = 0, pnamelist.count-1 {
			
			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_high")
			execute(tempstr)

			phivec.resize(phivec.size+1)
			phivec.x[phivec.size-1] = num
		}
	
	} else {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_high")
			execute(tempstr)
			
			phivec.x[k] = num
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// gets current parameter doarg in doargvec
proc getdoarg() {local k

	if (!doargvec.size) {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_doarg")
			execute(tempstr)

			doargvec.resize(doargvec.size+1)
			doargvec.x[doargvec.size-1] = num
		}
	
	} else {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_doarg")
			execute(tempstr)

			doargvec.x[k] = num
		}		
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// gets current parameter uselog in uselogvec
proc getuselog() {local k

	if (!uselogvec.size) {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_uselog")
			execute(tempstr)

			uselogvec.resize(uselogvec.size+1)
			uselogvec.x[uselogvec.size-1] = num
		}
	
	} else {

		for k = 0, pnamelist.count-1 {

			sprint(tempstr, "%s%s%s", "num = ", pnamelist.o(k).label, "_uselog")
			execute(tempstr)
			
			uselogvec.x[k] = num
		}
	}
}
// --------------------------------------------------------------------------------
