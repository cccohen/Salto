// Salto
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------Variables----------------------------------------
objref paramvec, solnvec, elogvec, plogvec, nefunvec, optibox
objref genvec, spacemat, genvec, mutmat, permvec, chkparamvec, chkparamboundsvec
objref pmat, tmat, vvec, simvec, rangemat
objref eqlist, pqlist, tlist, exitlist
objref boundvec, origboundlist, newboundlist, weightvec, weightmat, origweightlist, newweightlist, errlist, scalelist
objref drand, diamvec, speedvec, graphobj, prand, krand

solnvec = new Vector()
genvec = new Vector()
spacemat = new Matrix()
chkparamvec = new Vector()
chkparamboundsvec = new Vector()

prand = new Random()

elogvec = new Vector()
plogvec = new Vector()
nefunvec = new Vector()

strdef pheader, eheader, vheader, pnnheader, varstr, plogdir, elogdir, logdir, logstr, logmatstr, datastr, esimstr, psimstr
strdef mutstart, mutp, mutcom, mutend, mutexec
strdef rampstr1, rampstr2, rampstr3, rampstr4, rampstr5, rampstr6

nefun_ = 0
nquad_ = 0
fitoff = 1
hourlog = 1
chkhour = 2

// number of genetic divisions into which each paramater's parameter space 
// will be distributed.
nd = 2

esim = -1
psim = -1

newg = 0
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// $1 = mode_
proc adj_injbound() {local f, pifdelt, k localobj tempxvec

	if (!$1) {
	
		for f = 0, nf-1 {

			if (injvec.x[f]) {

				// search for index in xdat at which x >= pifdel
				pifdelt = RegionFitness[f].xdat.x[RegionFitness[f].xdat.indwhere(">=", getpifdel())]
		
				if (RegionFitness[f].boundary.x[0] < pifdelt) {
		
					RegionFitness[f].boundary.x[0] = pifdelt
					RegionFitness[f].weight.x[0] = 0

					tempxvec = new Vector(RegionFitness[f].xdat.size)
					
					for k = 0, tempxvec.size-1 {

						tempxvec.x[k] = RegionFitness[f].xdat.x[k]
					}
					
					RegionFitness[f].set_modelx(tempxvec)
					
					num = setnsig(pifdelt, 5)

					if (numarg() == 2 && argtype(2) == 0) {

						if ($2) {

							print "Fit start time adjusted to ", num, "ms for ", FitnessGenerator[0].yvarlist.o(f).s
						}
					}
				}
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// Places a voltage derivative-adjusted weight scale on voltage traces. No arguments.

proc adj_weight() {local points_to_adv, f, k, lo_bound, up_bound, indlo, indhi localobj tempvec, tempxvec, tempyvec, boundvec, weightvec

	points_to_adv = 1/dt/bess
	tempvec = new Vector()
	tempvec.resize(tempvec.size+1)
	tempvec.x[tempvec.size-1] = points_to_adv
	tempvec.floor()
	points_to_adv = tempvec.x[tempvec.size-1]

	for f = 0, nf-1 {

		lo_bound = RegionFitness[f].boundary.x[0]
		up_bound = RegionFitness[f].boundary.x[RegionFitness[f].boundary.size-1]

		tempxvec = new Vector(RegionFitness[f].xdat.size)
		
		for k = 0, tempxvec.size-1 {

			tempxvec.x[k] = RegionFitness[f].xdat.x[k]
		}

		tempyvec = new Vector(RegionFitness[f].ydat.size)
		
		for k = 0, tempyvec.size-1 {

			tempyvec.x[k] = RegionFitness[f].ydat.x[k]
		}

		indlo = tempxvec.indwhere("==", lo_bound)
		indhi = tempxvec.indwhere("==", up_bound)
				
		tempvec = new Vector()
		boundvec = new Vector()

		k = indlo
		while (k <= indhi-points_to_adv+1) {
			
			boundvec.append(tempxvec.x[k])
			tempvec.append(tempyvec.mean(k, k+points_to_adv-1))
			k += points_to_adv			
		}

		boundvec.append(tempxvec.x[indhi])		

		tempvec.deriv(bess*dt, 1)

		tempvec.resize(tempvec.size+1)
		tempvec.x[tempvec.size-1] = tempvec.x[tempvec.size-2]
		
		for k = 0, tempvec.size-1 {

			tempvec.x[k] = abs(tempvec.x[k])
			
			if (tempvec.x[k] < 1) {

				tempvec.x[k] = 1
			}
		}

		weightvec = new Vector(tempvec.size+1)
		weightvec.x[0] = 0

		for k = 1, weightvec.size-1 {

			weightvec.x[k] = tempvec.x[k-1]
		}		

		RegionFitness[f].boundary = new Vector(boundvec.size)

		for k = 0, boundvec.size-1 {

			RegionFitness[f].boundary.x[k] = boundvec.x[k]	
		}
		
		RegionFitness[f].weight = new Vector(weightvec.size)

		for k = 0, weightvec.size-1 {

			RegionFitness[f].weight.x[k] = weightvec.x[k]
		}

		RegionFitness[f].set_modelx(tempxvec)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc add_weight() {local f, k, points_to_adv, lo_bound, up_bound, indlo, indhi, nbound, ind, tempnum, m, sizecount localobj tempvec, origboundlist, boundvec, newboundlist, origweightlist, newweightlist, testvec, errlist, scalelist, weightvec	

	points_to_adv = min_weight*(1/dt/bess)
	tempvec = new Vector()
	tempvec.append(points_to_adv)
	tempvec.floor()
	points_to_adv = tempvec.x[0]

	crveclist(origboundlist, nf)
	crveclist(newboundlist, nf)

	crveclist(origweightlist, nf)

	// save original boundary/weight vecs in origbound/origweightlist, and create new boundary vecs in newboundlist
	for f = 0, nf-1 {
			
		origboundlist.o(f).resize(RegionFitness[f].boundary.size)
		
		for k = 0, origboundlist.o(f).size-1 {

			origboundlist.o(f).x[k] = RegionFitness[f].boundary.x[k]
		}

		origweightlist.o(f).resize(RegionFitness[f].weight.size)
		
		for k = 0, origweightlist.o(f).size-1 {

			origweightlist.o(f).x[k] = RegionFitness[f].weight.x[k]
		}

		tempxvec = new Vector(RegionFitness[f].xdat.size)
		
		for k = 0, tempxvec.size-1 {

			tempxvec.x[k] = RegionFitness[f].xdat.x[k]
		}

		lo_bound = origboundlist.o(f).x[0]
		up_bound = origboundlist.o(f).x[origboundlist.o(f).size-1]

		indlo = tempxvec.indwhere("==", lo_bound)
		indhi = tempxvec.indwhere("==", up_bound)		
		
		nbound = (indhi-indlo+1)/points_to_adv
		tempvec = new Vector()
		tempvec.resize(tempvec.size+1)
		tempvec.x[tempvec.size-1] = nbound
		tempvec.floor()
		nbound = tempvec.x[tempvec.size-1]

		if (nbound < min_weight) {

			print "add_weight() cannot be used for fit variable ", f, "because nbound = ", nbound, " is too low or min_weight = ", min_weight, " is too high..."
			print "Consider increasing the total range of weight intervals..."
			stop
		}

		boundvec = new Vector()
		boundvec.resize(boundvec.size+1)
		boundvec.x[boundvec.size-1] = tempxvec.x[indlo]

		k = indlo
		while (k <= indhi-points_to_adv+1) {

			boundvec.resize(boundvec.size+1)
			boundvec.x[boundvec.size-1] = tempxvec.x[k+points_to_adv-1]
			k += points_to_adv
		}

		if (boundvec.size < nbound+1) {

			boundvec.resize(boundvec.size+1)
			boundvec.x[boundvec.size+1] = tempxvec.x[indhi]
		}

		newboundlist.o(f).resize(boundvec.size)
		
		for k = 0, newboundlist.o(f).size-1 {

			newboundlist.o(f).x[k] = boundvec.x[k]
		}
	}
	
	// create new weight vecs in newweightlist
	tempnum = 0
	
	for f = 0, nf-1 {

		tempnum += newboundlist.o(f).size
	}

	crveclist(newweightlist, tempnum-nf)

	for f = 0, nf-1 {

		weightmat = new Matrix(newboundlist.o(f).size, newboundlist.o(f).size-1)
		
		for k = 0, weightmat.ncol-1 {

			weightmat.x[0][k] = origweightlist.o(f).x[0]
		}

		weightvec = new Vector(weightmat.nrow, 0)
		weightvec.x[0] = origweightlist.o(f).x[0]

		weightvec.x[1] = 1
		weightmat.setcol(0, weightvec)

		k = 1
		while (k <= weightmat.ncol-1) {

			if (weightvec.x[k] == 1) {

				weightvec.x[k] = 0
				weightvec.x[k+1] = 1
				weightmat.setcol(k, weightvec)
			}

			k += 1
		}

		for k = 0, weightmat.ncol-1 {

			newweightlist.o(f*weightmat.ncol+k).resize(weightmat.nrow)
			
			for m = 0, newweightlist.o(f*weightmat.ncol+k).size-1 {

				newweightlist.o(f*weightmat.ncol+k).x[m] = weightmat.x[m][k]
			}
		}
	}

	// create a list containing the errors from each newboundlist and newweightlist combination
	crveclist(errlist, nf)
	
	// size-1 because not counting the first bound/weight, which is always 0
	for k = 0, errlist.count-1 {

		errlist.o(k).resize(newboundlist.o(k).size-1)
	}

	// determine if all new weightvecs will be of equal size, to save time
	testvec = new Vector(newboundlist.count)
	
	for k = 0, testvec.size-1 {

		testvec.x[k] = newboundlist.o(k).size-1
	}
	
	tempnum = 0
	
	for k = 0, testvec.size-2 {

		if (testvec.x[k] == testvec.x[k+1]) {

			tempnum += 1
		}
	}

	if (tempnum == testvec.size-1) {
	
		print "Add weight activated (one run per interval)..."

		for m = 0, newboundlist.o(0).size-2 {

			for f = 0, nf-1 {

				RegionFitness[f].boundary = new Vector(newboundlist.o(f).size)
				
				for k = 0, RegionFitness[f].boundary.size-1 {

					RegionFitness[f].boundary.x[k] = newboundlist.o(f).x[k]
				}
					
				RegionFitness[f].weight = new Vector(newweightlist.o(f*(newboundlist.o(0).size-1)+m).size)
				
				for k = 0, RegionFitness[f].weight.size-1 {

					RegionFitness[f].weight.x[k] = newweightlist.o(f*(newboundlist.o(0).size-1)+m).x[k]
				}				

				tempxvec = new Vector(RegionFitness[f].xdat.size)
				
				for k = 0, tempxvec.size-1 {

					tempxvec.x[k] = RegionFitness[f].xdat.x[k]
				}

				RegionFitness[f].set_modelx(tempxvec)
			}

			print "Checking interval ", m+1, "of ", newboundlist.o(0).size-1
			nopelog()
			FitnessGenerator[0].efun()
			pelog()

			for k = 0, errlist.count-1 {

				errlist.o(k).x[m] = RegionFitness[k].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(k), RegionFitness[k].dw_)
			}
		}
	
	} else {
	
		print "Add weight activated (one run per interval per fit variable)..."

		sizecount = 0

		for f = 0, nf-1 {

			sizecount += newboundlist.o(f).size-1
			
			for k = sizecount-(newboundlist.o(f).size-1), sizecount-1 {

				RegionFitness[f].boundary = new Vector(newboundlist.o(f).size)
				
				for m = 0, RegionFitness[f].boundary.size-1 {

					RegionFitness[f].boundary.x[m] = newboundlist.o(f).x[m]
				}
				
				RegionFitness[f].weight = new Vector(newweightlist.o(k).size)
				
				for m = 0, RegionFitness[f].weight.size-1 {

					RegionFitness[f].weight.x[m] = newweightlist.o(k).x[m]
				}

				tempxvec = new Vector(RegionFitness[f].xdat.size)
				
				for m = 0, tempxvec.size-1 {

					tempxvec.x[m] = RegionFitness[f].xdat.x[m]
				}

				RegionFitness[f].set_modelx(tempxvec)

				print "Checking interval ", k+1, "of ", testvec.sum
				nopelog()
				FitnessGenerator[0].efun()
				pelog()

				errlist.o(f).x[k] = RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_)
			}
		}
	}

	// calculate ratio of weight to scale for each time/bound interval, and place these in scalelist.
	crveclist(scalelist, errlist.count)
	
	for k = 0, scalelist.count-1 {

		scalelist.o(k).resize(errlist.o(k).size)
	}

	// append minimum errors from each fit variable's error run over the selected intervals
	tempvec = new Vector(errlist.count)
	
	for k = 0, tempvec.size-1 {

		tempvec.x[k] = errlist.o(k).min
	}

	// calculate ratio to min error
	for k = 0, scalelist.count-1 {

		for m = 0, scalelist.o(k).size-1 {

			scalelist.o(k).x[m] = errlist.o(k).x[m]/tempvec.x[k]
		}
	}

	// apply the new weight scale
	for f = 0, nf-1 {

		RegionFitness[f].weight = new Vector(scalelist.o(f).size+1)
		RegionFitness[f].boundary = new Vector(newboundlist.o(f).size)

		for k = 1, RegionFitness[f].weight.size-1 {

			RegionFitness[f].weight.x[k] = scalelist.o(f).x[k-1]
		}

		for k = 0, RegionFitness[f].boundary.size-1 {

			RegionFitness[f].boundary.x[k] = newboundlist.o(f).x[k]
		}

		tempxvec = new Vector(RegionFitness[f].xdat.size)

		for k = 0, tempxvec.size-1 {

			tempxvec.x[k] = RegionFitness[f].xdat.x[k]
		}		

		RegionFitness[f].set_modelx(tempxvec)
	}

	initfit($1, $2)

	print "add weight ended..."
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getnp() {

	return ParmFitness[0].parmlist.count()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getpheader() {local p

	sprint(pheader, "%s", "")
	
	for p = 0, pnamelist.count-1 {

		sprint(pheader, "%s%s\t", pheader, pnamelist.o(p).label)
	}
	
	sprint(pheader, "%s\n", pheader)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc geteheader() {local f
	
	// construct emat/elogmat header
	// each col fitvar name, then col total, then tol
	sprint(eheader, "%s", "")
	
	for f = 0, nf-1 {

		sprint(eheader, "%s%s\t", eheader, fitvarlist.o(f).label)
	}
	
	sprint(eheader, "%s\t%s\t%s\n", eheader, "total", "tol")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getvheader() {local f, k

	// construct vmat header
	// col0 = time, col1,...,coln = v(fit variables)
	sprint(vheader, "%s", "time")
	
	for k = 0, $1-1 {

		for f = 0, nf-1 {

			sprint(vheader, "%s\t%s", vheader, fitvarlist.o(f).label)
		}
	}
	
	sprint(vheader, "%s\n", vheader)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getpnnheader() {local p

	sprint(pnnheader, "%s", "")
	
	for p = 0, pnamelist.count-1 {

		sprint(pnnheader, "%s%s%s\t", pnnheader, pnamelist.o(p).label, "_nn")
	}
	
	sprint(pnnheader, "%s\n", pnnheader)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc initfit() {

	elogvec.resize(0)
	plogvec.resize(0)
	nefunvec.resize(0)

	initchkparam($1, $2)

	nefun_ = 0
	nquad_ = 0
	runtime = 0
	fitoff = 1
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
proc updparampanel() {local p

	for p = 0, getnp()-1 {

		pvec.x[p] = RunFitParm[p].val * plowvec.x[p]
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func chktime() {localobj krand

	krand = new Random()

	if (runtime >= hourlog * krand.uniform($1*3600, $2*3600)) {

		hourlog += 1

		return 1
	
	} else {

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc nopelog() {

	sprint(esimstr, "%s", elogvec.label)
	sprint(psimstr, "%s", plogvec.label)

	sscanf(esimstr, "%lf", &esim)
	sscanf(psimstr, "%lf", &psim)

	elogvec.label("")
	plogvec.label("")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc pelog() {

	if (!numarg()) {
		
		elogvec.label(esimstr)
		plogvec.label(psimstr)

		sscanf(esimstr, "%lf", &esim)
		sscanf(psimstr, "%lf", &psim)
	}

	if (numarg() == 1 && argtype(1) == 0) {

		esim = $1
		sprint(esimstr, "%g", esim)
		elogvec.label(esimstr)
	}

	if (numarg() == 2 && argtype(1) == 0 && argtype(2) == 0) {

		esim = $1
		sprint(esimstr, "%g", esim)
		elogvec.label(esimstr)

		psim = $2
		sprint(psimstr, "%g", psim)
		plogvec.label(psimstr)
	}

	if (numarg() == 1 && argtype(1) == 2) {

		sprint(esimstr, "%s", $s1)
		sscanf($s1, "%lf", &esim)
		elogvec.label(esimstr)
	}

	if (numarg() == 2 && argtype(1) == 2 && argtype(2) == 2) {

		sprint(esimstr, "%s", $s1)
		sscanf($s1, "%lf", &esim)
		elogvec.label(esimstr)

		sprint(psimstr, "%s", $s2)
		sscanf($s2, "%lf", &psim)
		plogvec.label(psimstr)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// update error and parameter log. REQUIRES A MINIMUM OF 1 FIT RUN 
// WITH THE PARAMETERS OF CHOICE to record these, as well as their corresponding error.

proc updpelog() {local f, p, ydatsize, yfitsize

	if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

		ydatsize = 0
		yfitsize = 0

		for f = 0, nf-1 {

			ydatsize += RegionFitness[f].ydat_.size
			yfitsize += FitnessGenerator[0].yveclist.o(f).size
		}

		if (ydatsize == yfitsize) {

			elogvec.resize(elogvec.size+nf+1)

			for f = 0, nf-1 {

				elogvec.x[elogvec.size-(nf+1)+f] = RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_)
				elogvec.x[elogvec.size-1] += elogvec.x[elogvec.size-(nf+1)+f]
			}

			plogvec.resize(plogvec.size+getnp())

			for p = 0, getnp()-1 {

				plogvec.x[plogvec.size-getnp()+p] = RunFitParm[p].val
			}

			if (chktime(chkhour, chkhour+0.2)) {

				savepelog()
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc savepelog() {local k, has_iampdir localobj tempvec

	if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

		sscanf(elogvec.label, "%lf", &esim)
		sscanf(plogvec.label, "%lf", &psim)

		if (numarg() == 3 && argtype(1) == 0 && argtype(2) == 2 && argtype(3) == 2) {

			has_iampdir = getiampdir($1, $s2, $s3)
			sprint(iampstr, "%s", $s2)
			sprint(iampdir, "%s", $s3)
		
		} else {

			has_iampdir = getiampdir()
		}

		if (has_iampdir) {

			if (elogvec.size && plogvec.size) {

				if (chkdir(iampdir, "elog") && chkdir(iampdir, "plog")) {

					sprint(elogdir, "%s%s", iampdir, "elog/")
					sprint(plogdir, "%s%s", iampdir, "plog/")
									
					sprint(format, "%s%s", "%s", vformvec)

					sprint(datastr, "%s", "")

					// save elog
					for k = 0, elogvec.size-1 {

						sprint(datastr, format, datastr, elogvec.x[k])
					}

					elogvec.resize(0)

					sprint(filestr, "%s%s", elogvec.label, ".dat")

					writestr(elogdir, filestr, datastr, 1)

					sprint(datastr, "%s", "")

					sprint(format, "%s%s", "%s", maxformvec)

					// save plog
					for k = 0, plogvec.size-1 {

						sprint(datastr, format, datastr, plogvec.x[k])
					}

					plogvec.resize(0)

					sprint(filestr, "%s%s", plogvec.label, ".dat")

					writestr(plogdir, filestr, datastr, 1)

					sprint(datastr, "%s", "")
				
				} else {		

					crdir(iampdir, "elog")
					crdir(iampdir, "plog")

					savepelog()
				}
			
			} else {

				if (!chkdir(iampdir, "elog") && !chkdir(iampdir, "plog")) {

					crdir(iampdir, "elog")
					crdir(iampdir, "plog")
				}
			}
		
		} else {

			if (chkdir(root, "data")) {

				getmod()

				if (chkdir(data, modstr)) {

					crdir(moddir, iampstr)
					savepelog()
				
				} else {

					crdir(data, modstr)
					savepelog()
				}
			
			} else {

				crdir(root, "data")
				savepelog()
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getpelogdirs() {

	if (numarg() == 0) {

		getiampdir()
		sprint(elogdir, "%s%s", iampdir, "elog/")
		sprint(plogdir, "%s%s", iampdir, "plog/")
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// updates both pnorm and corresponding RunFitParm with pnorm arguments
proc updfitparam() {local p, i, k

	if (argtype(1) == 1) {

		// whole vector input
		if (numarg() == 1 && argtype(1) == 1) {

			for p = 0, $o1.size-1 {

				setpnorm(p, $o1.x[p])
				getpnorm(p, $o1.x[p])
				RunFitParm[p].val = $o1.x[p]
			}

		// vector + vector range from $2 to $3 as input 
		} else if (numarg() == 3 && argtype(1) == 1) {

			for k = 0, $o1.size-1 {

				setpnorm(k+$2, $o1.x[k])
				getpnorm(k+$2, $o1.x[k])
				RunFitParm[k+$2].val = $o1.x[k]
			}
		}
	
	// input as individual parameters 
	} else {

		for i = 1, numarg() {
			
			setpnorm(i-1, $i)
			getpnorm(i-1, $i)
			RunFitParm[i-1].val = $i
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc updrfp() {local k, tempnum

	getpnorm()
	tempnum = ParmFitness[0].parmlist.count

	for k = 0, pnormvec.size-1 {

		if (k < tempnum) {

			sprint(tempstr, "%s%s", pnamelist.o(k).label, "_norm")
			
			if (uselogvec.x[k]) {
			
				ParmFitness[0].parmlist.o(k).set(tempstr, pnormvec.x[k], 1, phivec.x[k]/plowvec.x[k], doargvec.x[k], uselogvec.x[k])
			
			} else {
			
				if (plowvec.x[k] < 0 && phivec.x[k] >= 0) {
			
					ParmFitness[0].parmlist.o(k).set(tempstr, pnormvec.x[k], phivec.x[k]/plowvec.x[k], 1, doargvec.x[k], uselogvec.x[k])
				}
			}

			tempobj = ParmFitness[0].parmlist.o(k)
			tempobj.setname(tempstr)
			ParmFitness[0].parmlist.remove(k)
			ParmFitness[0].parmlist.insrt(k, tempobj)
			objref tempobj
			objref domainbox, domainlist, parmbox

		} else {

			sprint(tempstr, "%s%s", pnamelist.o(k).label, "_norm")			
			tempobj = new RunFitParm(tempstr)

			if (uselogvec.x[k]) {
			
				tempobj.set(tempstr, pnormvec.x[k], 1, phivec.x[k]/plowvec.x[k], doargvec.x[k], uselogvec.x[k])
			
			} else {
			
				if (plowvec.x[k] < 0 && phivec.x[k] >= 0) {
			
					tempobj.set(tempstr, pnormvec.x[k], phivec.x[k]/plowvec.x[k], 1, doargvec.x[k], uselogvec.x[k])
				}
			}
			
			ParmFitness[0].declare(tempobj)
			ParmFitness[0].parmlist.append(tempobj)
			objref domainbox, domainlist, parmbox
			
			if (strf.head(tempstr, "\\$", teststr) == -1) {

				sprint(tempstr, "%s", "")
				sprint(tempstr, "%s.val = %s", tempobj, tempstr)
				execute1(tempstr)
			}
		}
	}

	if (pnormvec.size < ParmFitness[0].parmlist.count) {

		tempnum = ParmFitness[0].parmlist.count - pnormvec.size

		k = 0
		while (k < tempnum) {

			ParmFitness[0].parmlist.remove(ParmFitness[0].parmlist.count-1)
			objref domainbox, domainlist, parmbox
			k += 1
		}
	}

	ParmFitness[0].def_parmlist_use()

	objref tempobj
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc initpnormdef() {local p

	for p = 0, getnp()-1 {

		RunFitParm[p].val = pnormdefvec.x[p]
		setpnorm(p, pnormdefvec.x[p])
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc showdom() {

	ParmFitnessGui[0].showdomain(1637.9, 724, 218.74, 213.12)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// set to-be-optimized parameters.
func setgen() {local p, tempnum

	genvec.resize(0)	

	if ($1 == 0) {

		for p = 0, doargvec.size-2 {

			if (doargvec.x[p]) {

				genvec.resize(genvec.size+1)
				genvec.x[genvec.size-1] = p
			}
		}
	
	} else if ($1 == 1) {

		tempnum = setnp(0, 0)

		if (SOAX) {

			genvec.resize(8)
			
			// Selected parameters
			// Na: prox, ais, int, nod
			// Kv1: prox, ais, int, juxta, nod

			// Na_prox
			genvec.x[0] = tempnum+2
			// Na_ais
			genvec.x[1] = tempnum+3
			// Na_int
			genvec.x[2] = tempnum+4
			// Na_nod
			genvec.x[3] = tempnum+5

			// Kv1_prox
			genvec.x[4] = tempnum+14
			// Kv1_ais
			genvec.x[5] = tempnum+15
			// Kv1_int
			genvec.x[6] = tempnum+16
			// Kv1_nod
			genvec.x[7] = tempnum+17

			// Kv1_juxta
			if (axontype == 4) {

				genvec.resize(genvec.size+1)
				genvec.x[genvec.size-1] = tempnum+35
			}
		}
	}
	
	ns = nd^(genvec.size)

	spacegen()
	getmutation(ns)

	return ns
}
// --------------------------------------------------------------------------------



// ---------------------------------------------------------------------------------------
// delimit the domains in parameter space, from which a randomly chosen base, 
// or initial condition, will be mutated and expressed. Excludes the very weakly-constrained 
// Cpip, which will still be optimized, but as a "silent" gene.

proc spacegen() {local m, p
	
	spacemat.resize(nd+1, genvec.size)

	for m = 0, spacemat.nrow-1 {
			
		for p = 0, spacemat.ncol-1 {

			spacemat.x[m][p] = 1 + m*(((phivec.x[genvec.x[p]]/plowvec.x[genvec.x[p]])-1)/nd)
		}
	}
}
// ---------------------------------------------------------------------------------------



// ---------------------------------------------------------------------------------------
// procedure for getting  mutation possibilities, which are really just
// permutations of all possible pspace row indices (row = 0, row = nrow-2).
// i.e. if nd = 2, there are 2 possible pspace rows indices, representing
// the 2 states of the variable: (row = 0, row = 1) and (row = 1, row = 2).

proc getmutation() {local k, m localobj tempvec
	
	mutmat = new Matrix($1, genvec.size)
	tempvec = new Vector(genvec.size)

	if (nd == 1) {

		for k = 0, mutmat.nrow-1 {

			mutmat.setrow(k, tempvec)
		}

	} else {

		mutsim = 0
		sprint(mutstart, "%s", "")
		sprint(mutp, "%s", "")
		sprint(mutend, "%s", "")

		for k = 0, tempvec.size-1 {

			sprint(mutstart, "%s%s%d%s", mutstart, "for p", k, " = 0, nd-1 {\n")
			sprint(mutp, "%s%s%d%s", mutp, "p", k, ",")
			sprint(mutend, "%s%s", mutend, "}\n")
		}

		strf.left(mutp, strf.len(mutp)-1)
		sprint(mutcom, "%s%s%s", "permvec = new Vector()\npermvec.append(", mutp, ")\nmutmat.setrow(mutsim, permvec)\nmutsim+=1\n")
		sprint(mutexec, "%s%s%s", mutstart, mutcom, mutend)
		execute(mutexec)

		mutsim = 0
		sprint(mutstart, "%s", "")
		sprint(mutp, "%s", "")
		sprint(mutend, "%s", "")
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc initchkparam() {local k, p, unitsize, tempnum

	// Note: only vector objects seem to cross the para/non-para line for functions
	// called by init(). init() also does not take arguments, to maintain compatibility with
	// with other programme calls.	
	chkparamvec.resize(4*(unitsize = setnp($1, $2)))
	
	for p = 0, unitsize-1 {

		// column 0: eligibility for repicking or biophysical boundary imposition
		chkparamvec.x[p] = 1
		// column 1: initialized to 0, i.e. no repicking or changing the given parameter.
		// column 2: lower biophysical bound (norm)
		chkparamvec.x[2*unitsize+p] = 1
		// column 3: upper biophysical bound
		chkparamvec.x[3*unitsize+p] = phivec.x[p]/plowvec.x[p]
	}

	// remove eligibility from already optimal or currently non-optimized parameters (in increasing order of parameter numbers)
	if (solnvec.size) {

		for p = 0, solnvec.size-1 {

			chkparamvec.x[p] = 0
		}
	}

	if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

		sscanf(elogvec.label, "%lf", &esim)
		sscanf(plogvec.label, "%lf", &psim)

		if (esim > -1 && psim > -1) {

			for p = 0, unitsize-1 {

				chkparamvec.x[p] = 1
			}
		
		} else {

			for p = 0, unitsize-1 {

				chkparamvec.x[p] = 0
			}
		}
	}

	tempnum = setnp(0, 0)

	for p = 0, unitsize-1 {

		if (!doargvec.x[p] || !$2) {

			chkparamvec.x[p] = 0
		}

		// lc_Na_de: sufficiently restricted by Na_so		
		if (p == 1+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Na_end: no effective restriction can me made
		if (p == 6+tempnum) {

			chkparamvec.x[p] = 0
		}		

		// Nap_ais: no clear evidence of more or less Nap anywhere along the primary axon, just its presence
		if (p == 8+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Nap_int: no clear evidence of more or less Nap anywhere along the primary axon, just its presence
		if (p == 9+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Nap_nod: no clear evidence of more or less Nap anywhere along the primary axon, just its presence
		if (p == 10+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Nap_end: no clear evidence of more or less Nap anywhere along the primary axon, just its presence
		if (p == 11+tempnum) {

			chkparamvec.x[p] = 0
		}

		// lc_Kv1_Kv_de is sufficiently restricted by Kv1_so and Kv_so
		if (p == 13+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Kv1_end: no clear restrictions
		if (p == 18+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Kv_so: no clear restrictions
		if (p == 20+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Kv7_prox: no clear restrictions
		if (p == 23+tempnum) {

			chkparamvec.x[p] = 0
		}

		// Kv7_end: no clear restrictions
		if (p == 27+tempnum) {
			
			chkparamvec.x[p] = 0
		}

		// KCa: no clear restrictions
		if (p == 29+tempnum) {
			
			chkparamvec.x[p] = 0
		}

		// Ca: no clear restrictions
		if (p == 30+tempnum) {
			
			chkparamvec.x[p] = 0
		}

		// It2: no clear restrictions
		if (p == 31+tempnum) {
			
			chkparamvec.x[p] = 0
		}

		// H_so: no clear restrictions
		if (p == 32+tempnum) {
			
			chkparamvec.x[p] = 0
		}

		// tc_H_de: no clear restrictions
		if (p == 33+tempnum) {
			
			chkparamvec.x[p] = 0
		}

		// H_ax: no clear restrictions
		if (p == 34+tempnum) {
			
			chkparamvec.x[p] = 0
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc chkparam() {local p, unitsize, tempnum

	if ($1 == 1 && $2) {

		if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

			sscanf(elogvec.label, "%lf", &esim)
			sscanf(plogvec.label, "%lf", &psim)

			if (esim > -1 && psim > -1) {

				unitsize = $o3.size/4

				if (esim == 0 && psim == 0) {

					for p = 0, genvec.size-1 {

						$o3.x[2*unitsize+genvec.x[p]] = spacemat.x[0][p]
						$o3.x[3*unitsize+genvec.x[p]] = spacemat.x[spacemat.nrow-1][p]
					}
				
				} else {

					for p = 0, genvec.size-1 {

						$o3.x[2*unitsize+genvec.x[p]] = spacemat.x[mutmat.x[psim-1][p]][p]
						$o3.x[3*unitsize+genvec.x[p]] = spacemat.x[mutmat.x[psim-1][p]+1][p]
					}
				}

				tempnum = setnp(0, 0)

				for p = 0, unitsize-1 {

					if ($o3.x[p]) {

						// Na_so
						if (p == 0+tempnum) {

							// if Na_so < Na_ais, and Na_nod
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[3+tempnum].val*plowvec.x[3+tempnum] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[5+tempnum].val*plowvec.x[5+tempnum]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Na_prox
						if (p == 2+tempnum) {

							// if Na_prox > Na_int, Na_col
							if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[4+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[7+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}				

						// Na_ais
						if (p == 3+tempnum) {

							// if Na_ais > Na_so, Na_int, Na_col
							if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[0+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[4+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[7+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Na_int
						if (p == 4+tempnum) {

							// if Na_int < Na_prox, Na_ais, Na_nod
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[2+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[3+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[5+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Na_nod
						if (p == 5+tempnum) {

							// if Na_nod > Na_so, Na_int, Na_col
							if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[0+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[4+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[7+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Na_col
						if (p == 7+tempnum) {

							// if Na_col < Na_nod, Na_ais, Na_prox
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[2+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[3+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[5+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv1_so
						if (p == 12+tempnum) {

							// Kv1_so < Kv1_ais, Kv1_juxta (if present)
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[15+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0

								if (axontype == 4 && RunFitParm[p].val*plowvec.x[p] >= RunFitParm[35+tempnum].val*plowvec.x[p]) {

									$o3.x[unitsize+p] = 1
								}
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv1_prox
						if (p == 14+tempnum) {

							// Kv1_prox > Kv1_int, Kv1_nod (mammals), Kv1_col
							if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[16+tempnum].val*plowvec.x[16+tempnum] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[17+tempnum].val*plowvec.x[17+tempnum] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[19+tempnum].val*plowvec.x[19+tempnum]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv1_ais
						if (p == 15+tempnum) {

							// if Kv1_ais > Kv1_so, Kv1_int, Kv1_nod (mammals), Kv1_col
							if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[12+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[16+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[17+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[19+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv1_int
						if (p == 16+tempnum) {

							// Kv1_int < Kv1_prox, Kv1_ais, Kv1_juxta
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[14+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[15+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0

								if (axontype == 4 && RunFitParm[p].val*plowvec.x[p] >= RunFitParm[35+tempnum].val*plowvec.x[p]) {

									$o3.x[unitsize+p] = 1
								}
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv1_nod
						if (p == 17+tempnum) {

							// Kv1_nod < Kv1_prox, Kv1_ais, Kv1_juxta
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[14+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[15+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0

								if (axontype == 4 && RunFitParm[p].val*plowvec.x[p] >= RunFitParm[35+tempnum].val*plowvec.x[p]) {

									$o3.x[unitsize+p] = 1
								}
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv1_col
						if (p == 19+tempnum) {

							// if Kv1_col < Kv1_prox, Kv1_ais, Kv1_juxta
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[14+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[15+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0

								if (axontype == 4 && RunFitParm[p].val*plowvec.x[p] >= RunFitParm[35+tempnum].val*plowvec.x[p]) {

									$o3.x[unitsize+p] = 1
								}
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv7_so
						if (p == 21+tempnum) {

							// if Kv7_so < Kv7_ais, Kv7_nod
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[24+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[26+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv7_de
						if (p == 22+tempnum) {

							// if Kv7_de < Kv7_ais, Kv7_nod
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[24+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[26+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv7_ais
						if (p == 24+tempnum) {

							// if Kv7_ais > Kv7_so, Kv7_de, Kv7_int, Kv7_col
							if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[21+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[22+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[25+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[28+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv7_int
						if (p == 25+tempnum) {

							// if Kv7_int < Kv7_ais, Kv7_nod
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[24+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[26+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv7_nod
						if (p == 26+tempnum) {

							// if Kv7_nod > Kv7_so, Kv7_de, Kv7_int, Kv7_col
							if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[21+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[22+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[25+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[28+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv7_col
						if (p == 28+tempnum) {

							// if Kv7_col < Kv7_ais, Kv7_nod
							if (RunFitParm[p].val*plowvec.x[p] < RunFitParm[24+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] < RunFitParm[26+tempnum].val*plowvec.x[p]) {

								$o3.x[unitsize+p] = 0
							
							} else {

								$o3.x[unitsize+p] = 1
							}
						}

						// Kv1_juxta
						if (axontype == 4) {

							if (p == 35+tempnum) {

								// if Kv1_juxta > Kv1_so, Kv1_int, Kv1_nod (mammals), Kv1_col
								if (RunFitParm[p].val*plowvec.x[p] > RunFitParm[12+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[16+tempnum].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[17].val*plowvec.x[p] && RunFitParm[p].val*plowvec.x[p] > RunFitParm[19].val*plowvec.x[p]) {

									$o3.x[unitsize+p] = 0
								
								} else {

									$o3.x[unitsize+p] = 1
								}
							}
						}
					}
				}
			}
		}
	}

	return $o3
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chkparambounds() {local p, unitsize, chkbound

	initchkparam($1, $2)
	unitsize = chkparamvec.size/4
	chkbound = 0

	for p = 0, unitsize-1 {		

		if (RunFitParm[p].val*plowvec.x[p] > phivec.x[p] || RunFitParm[p].val*plowvec.x[p] < plowvec.x[p]) {

			chkparamvec.x[p] = 1
			chkparamvec.x[unitsize+p] = 1
			chkbound = 1
		}
	}

	if (chkbound) {

		print "---------------------------"
		for i = 0, chkparamvec.size-1 {

			print "chkparamvec.x[", i, "] = ", chkparamvec.x[i]
		}
		print "---------------------------"

		updfitparam(mutchkparam(chkparamvec))
		initchkparam($1, $2)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc mutchkparam() {local p, unitsize localobj tempvec
	
	unitsize = $o1.size/4
	tempvec = new Vector(unitsize)

	for p = 0, unitsize-1 {

		if ($o1.x[p] && $o1.x[unitsize+p]) {
			
			tempvec.x[p] = prand.uniform($o1.x[2*unitsize+p], $o1.x[3*unitsize+p])
		
		} else {

			tempvec.x[p] = RunFitParm[p].val
		}
	}

	return tempvec
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc optimizewrap() {local nd_, np, tempnum, scount, total_scount, scounter, exitcount, r, k, maxtime_, tolopt, maxstepsizeopt, p, ucount, exit_case localobj rangemat

	nd_ = nd
	nd = 1

	setgen(mode_, idata)

	print "NU algorithm (GUI version)"
	getmod()

	if (mode_ == 0) {

		np = genvec.size

	} else {

		np = getnp()
	}
	
	print np, "parameters found for NU optimization (model type: ", modstr, ")"

	if ((tempnum = iampvec.indwhere("==", stim.amp)) > -1) {		

		scount = getscount(mode_, idata)

		rangemat = new Matrix(2, 1)
		
		rangemat.x[0][0] = tempnum
		rangemat.x[1][0] = tempnum

		total_scount = scount

		getiamp(tempnum, rampstr1)
		getiamp(tempnum, rampstr2)

		print "\nOptimization selected for stimulation amplitudes from ", rampstr1, " to ", rampstr2

		print "Total optimizations for selected injection amplitude(s) = ", total_scount, "\n"

		scounter = 0
		exitcount = 0

		crdir(root, "data")
		crdir(data, modstr)
		
		pmat = new Matrix(total_scount, getnp())
		eqlist = crveclist(eqlist, total_scount, 0)
		pqlist = crveclist(pqlist, total_scount, 0)
		exitlist = crveclist(exitlist, total_scount, 3)

		for r = 0, rangemat.ncol-1 {

			for k = rangemat.x[0][r], rangemat.x[1][r] {

				getiampdir(k, iampstr, iampdir)
				crdir(moddir, iampstr)
				savepelog(k)
				savelog(iampdir, "eq")
				savelog(iampdir, "pq")
				savelog(iampdir, "fe")
				savelog(iampdir, "fp")
				savelog(iampdir, "t")
				savelog(iampdir, "v")
				savelog(iampdir, "exit")
				saveopt(iampdir, scount)
				
				getsim(0, 0)

				print "\n", simvec.size, "simulation(s) chosen for injection amplitude ", iampstr			

				maxtime_ = maxtime
				maxtime = 1e9

				scounter += 1

				reseticlamp(mode_, idata, k, 0, 1)
				tolopt = settol(k, 1)
				maxstepsizeopt = setmaxstepsize(tolopt)

				pelog(0, 0)

				print "\nRunning simulation ", 1, "of ", 1, "for injection amplitude ", iampstr

				for p = 0, pmat.ncol-1 {

					pmat.x[0][p] = RunFitParm[p].val
				}

				initfit(mode_, idata)
				adj_injbound(mode_, 1)

				// ucount = 0 if simulation did not complete due to overtime
				ucount = 0

				// exit_case by default is 0 (= no exit), unless there is a reason to exit (=1)
				exit_case = 0

				// ensure fitoff first, to restore variables therafter
				// fitoff = 0

				// $1 = iiamp
				// $2 = mode_
				// $3 = ll
				// $4 = uopt
				// $o5 = p from pmat, to be optimized
				// $6 = tol
				// $7 = maxstepsize
				// $o8 = eqvec from eqlist, to be updated with resultant quad errors
				// $o9 = pqvec from pqlist, to be updated with resultant quad parameters
				// $10 = sim
				// $11 = scount
				// $o12 = exitlist vec
				// $13 = hoc_ac_ = internal id number; here, for GUI-based calls to optimize (718573=GUI)
				// $14 = ucount, local variable determining if simulation could not finish due to lack of time
				// $15 = exit_case, by default 0 (no exit) unless certain criteria are met (see optimize())			
				optimize(k, mode_, 0, 0, pmat.getrow(0), tolopt, maxstepsizeopt, eqlist.o(0), pqlist.o(0), simvec.x[0], 0, exitlist.o(0), 718573, ucount, exit_case)

				nd = nd_
				maxtime = maxtime_
			}
		}
	
	} else {

		print "\nVoltage response data must correspond to selected current injection amplitude\nStopping..."
		stop
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc setoptpanel() {

	optibox = new VBox(3)
	optibox.intercept(1)
	xpanel("", 1)
	xbutton("optimize", "optimizewrap()")
	xlabel(" spatially non-uniform parameter distributions")
	xpanel()
	xpanel("", 1)
	xpvalue("nquad", &nquad_, 0, "", 0, 1)
	xlabel(" ")
	xpvalue("nefun", &nefun_, 0, "", 0, 1)
	xpanel()
	optibox.intercept(0)
	optibox.map("Non-uniform (NU) optimization", 998, 961, 360.96, 93.12)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// change fit data according to iiamp and imported vdat
// $1 = iiamp
// $2 = mode_
proc changedata() {local f, k localobj boundvec, weightvec, tempxvec

	for f = 0, nf-1 {

		// store already set bounds, if different from default
		if (RegionFitness[f].boundary.x[0] != RegionFitness[f].xdat.x[0] || RegionFitness[f].boundary.x[RegionFitness[f].boundary.size-1] != RegionFitness[f].xdat.x[RegionFitness[f].xdat.size-1] || RegionFitness[f].boundary.size > 2) {

			// store those bounds in boundvec
			boundvec = new Vector(RegionFitness[f].boundary.size)

			for k = 0, boundvec.size-1 {

				boundvec.x[k] = RegionFitness[f].boundary.x[k]
			}

			// store associated time data
			tempxvec = new Vector(RegionFitness[f].xdat_.size)

			for k = 0, tempxvec.size-1 {

				tempxvec.x[k] = RegionFitness[f].xdat_.x[k]
			}
			
			// also store the associated weights in weightvec
			weightvec = new Vector(RegionFitness[f].weight.size)

			for k = 0, weightvec.size-1 {

				weightvec.x[k] = RegionFitness[f].weight.x[k]	
			}

			// set data to new iamp
			RegionFitness[f].set_data(vdatmat.getcol(0), vdatmat.getcol($1*nf+f+1))

			// restore previous boudaries and weights (the associated dw get taken care of)
			RegionFitness[f].boundary = new Vector(boundvec.size)

			for k = 0, boundvec.size-1 {

				RegionFitness[f].boundary.x[k] = boundvec.x[k]	
			}
			
			RegionFitness[f].weight = new Vector(weightvec.size)

			for k = 0, weightvec.size-1 {

				RegionFitness[f].weight.x[k] = weightvec.x[k]
			}
			
			RegionFitness[f].set_modelx(tempxvec)
		
		} else {

			// if already set bounds same as default, simply change data for new iamp
			RegionFitness[f].set_data(vdatmat.getcol(0), vdatmat.getcol($1*nf+f+1))
		}
	}

	strdef chgdata_iampstr
	getiamp($1, chgdata_iampstr)

	if ($2) {

		print "\nFit data changed to ", chgdata_iampstr, " voltage response"		
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc reseticlamp() {local wstart, wkill, win, interval, wcount
	
	{stim.amp = iampvec.x[$3]}
	
	if ($5) {

		printclamp()
	}
	
	changedata($3, $5)

	if ($4) {

		writenum(ses, iampfilestr, iampvec.x[$3])
		writefitdata($3)

		writevtplot($1, $2, iampvec.x[$3])
		writevxplot(iampvec.x[$3])
		writeshape(iampvec.x[$3])

		loadfile(1, ses, vtplotfilestr)
		loadfile(1, ses, vxplotfilestr)
		loadfile(1, ses, shapeplotfilestr)
	}
	
	// deprecated: as window replacement is slow and does not seem to work for every window type.
	// windows are therefore replaced directly on top of each other.
	// window replacement is best for GUI-based model exploration. Otherwise, 
	// substantial slowdown occurs with every cycle of window replacement.
	// if (!para) {
		
	// 	wstart = 3
	// 	wkill = 2+nf
	// 	win = wstart + getvar(ses, "resetbit.dat") * (PWM.count - wstart - wkill)
	// 	sprint(wstr, "%s%d%s", "PWM.close(", win, ")")
	// 	timer = new Timer(wstr)
	// 	interval = 0.2
	// 	timer.seconds(interval)
	// 	PWM.close(win)
	// 	wcount = win
		
	// 	while (wcount <= win+nf+1) {
	// 		timer.start()
	// 		wcount += 1
	// 	}
	// 	timer.end()

	// 	while (wcount <= win+nf+2) {
		
	// 		if (wcount > win+nf+1) {	

	// 			writevtplot(mode_, stim.amp)
	// 			writevxplot(mode_, stim.amp)
	// 			writeshape(mode_, stim.amp)

	// 			if (mode_ == 0) {
					
	// 				loadfile(1, ses, "vtplot-pas.ses")
	// 				loadfile(1, ses, "vxplot-pas.ses")
	// 				loadfile(1, ses, "shapeplot-pas.ses")

	// 			} else if (mode_ == 1) {

	// 				loadfile(1, ses, "vtplot-act.ses")
	// 				loadfile(1, ses, "vxplot-act.ses")
	// 				loadfile(1, ses, "shapeplot-act.ses")					
	// 			}

	// 			writebit(ses, "resetbit.dat", 1)

	// 			wcount = win+nf+3
	// 		}
	// 	}
		
	// 	wstr = ""
	// }
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getoptsoln() {local k localobj tempmat

	if (getiampdir()) {

		if (chkdir(iampdir, "\npmatr.dat") || chkdir(iampdir, "\npmatr-all.dat")) {

			if (chkdir(iampdir, "\npmatr.dat") && chkdir(iampdir, "\npmatr-all.dat")) {

				getmat(iampdir, "pmatr.dat", tempmat)
			
			} else if (!chkdir(iampdir, "\npmatr.dat") && chkdir(iampdir, "\npmatr-all.dat")) {

				getmat(iampdir, "pmatr-all.dat", tempmat)
			}

			solnvec = new Vector(tempmat.getrow(0).size)

			for k = 0, solnvec.size-1 {

				solnvec.x[k] = tempmat.getrow(0).x[k]
			}

			updfitparam(solnvec)

			print "\nOptimal parameters loaded for ", modstr, "/", iampstr

			return solnvec.size
		
		} else {

			print "\nOptimal parameters do not exist for ", modstr, "/", iampstr

			getoptpas($1, $2)

			return 0
		}
	
	} else {

		print "\nOptimization directory does not exist for ", modstr, "/", iampstr

		getoptpas($1, $2)

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getoptpas() {local k
	
	strdef optpas_modstr, optpas_moddir

	strf.tail(modstr, "-", optpas_modstr)
	sprint(optpas_modstr, "%s%s", "pas-", optpas_modstr)

	sprint(optpas_moddir, "%s%s%s", data, optpas_modstr, "/")
	
	if (chkdir(data, optpas_modstr)) {

		if (chkdir(optpas_moddir, "\npematr.dat")) {

			getmat(optpas_moddir, "pematr.dat", tempmat)

			if (!$1) {

				solnvec = new Vector(setnp($1, $2))
			
			} else {

				solnvec = new Vector(setnp(0, 0))
			}

			for k = 0, solnvec.size-1 {

				solnvec.x[k] = tempmat.getrow(tempmat.nrow-2).x[k]
			}

			updfitparam(solnvec)

			print "Optimal parameters loaded for ", optpas_modstr

			return solnvec.size
	
		} else {

			print "Optimal parameters do not exist for ", optpas_modstr

			return 0
		}
	
	} else {

		print "Parameter directory does not exist for ", optpas_modstr

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc perr() {local f

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "No arguments required. Will print each fit error sequentially."
			stop
		}
	}

	sprint(tempstr, "%s", "")

	for f = 0, nf-1 {

		sprint(numstr, vformvec, RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_))
		sprint(tempstr, "%s%s", tempstr, numstr)
	}

	print tempstr

	sprint(tempstr, "%s", "")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc ppnorm() {local k, tempnum

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "No arguments required. Will print each active pnorm."
			stop
		}
	}

	tempnum = setnp(0, 0)

	for k = tempnum, pnormvec.size-1 {

		print pnormvec.x[k]
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getsecparam() {local seg, countseg, pos, nrecrows, k localobj tempvec, tempmat

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) section name (string) or sectionlist (object)"
			print "2) variable of interest to record (\"v\" or \"vext\", as string)"
			print "3) optional file name header (especially for sectionlist names, as string)"
			stop
		}
	}

	countseg = 0

	if (argtype(1) == 2) {

		forsec $s1 {

			countseg = nseg 
		}
	
	} else {

		forsec $o1 {

			countseg += nseg
		}
	}

	nrecrows = tstop/dt
	
	tempvec = new Vector(1, nrecrows)
	
	tempvec.floor
	nrecrows = tempvec.x[0]+1
	
	crveclist(templist, countseg+1)
	
	for k = 0, templist.count-1 {

		templist.o(k).resize(nrecrows)
	}

	strdef exprtok_left, exprtok_right
	
	if (!strcmp($s2, "v")) {

		sprint(exprtok_left, ".v(")
	}
	
	if (!strcmp($s2, "vext")) {

		sprint(exprtok_left, ".vext(")
	}
	
	sprint(exprtok_right, ")")	
	
	templist.o(0).record(&t)
	num = 1
	strdef getsecparamstr
	
	if (argtype(1) == 2) {

		forsec $s1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(getsecparamstr, "%s%g%s%s%s%g%s%s", "~templist.o(", num, ").record(&", $s1, exprtok_left, pos, exprtok_right, exprtok_right)
			execute(getsecparamstr)
			num += 1
		}

	} else {

		forsec $o1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(getsecparamstr, "%s%g%s%s%s%g%s%s", "~templist.o(", num, ").record(&", secname(), exprtok_left, pos, exprtok_right, exprtok_right)
			execute(getsecparamstr)
			num += 1
		}
	}

	init()
	run()
	
	getmod()
	
	if (numarg() == 3 && argtype(3) == 2) {

		if (argtype(1) == 2) {

			sprint(tempstr, "%s%s%s%s%s%s%s%s", $s3, "_", $s1, "_", $s2, "_", modstr, ".dat")
		
		} else {

			sprint(tempstr, "%s%s%s%s%s%s", $s3, "_", $s2, "_", modstr, ".dat")	
		}

	} else {

		if (argtype(1) == 2) {

			sprint(tempstr, "%s%s%s%s%s%s", $s1, "_", $s2, "_", modstr, ".dat")
		
		} else {

			sprint(tempstr, "%s%s%s%s", $s2, "_", modstr, ".dat")	
		}				
	}
	
	tempmat = new Matrix(nrecrows, countseg+1)
	
	for k = 0, templist.count-1 {

		tempmat.setcol(k, templist.o(k))
	}
	
	savemat(ses, tempstr, tempmat, vformvec)

	objref templist
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc gadd() {local seg, pos

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Add v(t) plot"
			print "Enter:"
			print "1) section (string) or sectionlist (object) to plot"
			print "2) variable of interest to plot (string), e.g. \"v\" or \"vext\""
			stop
		}
	}

	strdef exprtok_left, exprtok_right
	
	if (!strcmp($s2, "v")) {

		sprint(exprtok_left, ".v(")
	}
	
	if (!strcmp($s2, "vext")) {

		sprint(exprtok_left, ".vext(")
	}
	
	sprint(exprtok_right, ")")
	
	if (!newg) {

		graphobj = new Graph(0)
		graphobj.size(-1e-7, tstop, -80, 40)
		graphobj.view(-1e-7, -80, tstop, 120, 612, 726, 678.72, 277.12)		
		newg = 1
	
	} else {

		graphobj.erase_all()
	}

	if (argtype(1) == 2) {
	
		forsec $s2 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(varstr, "%s%s%g%s", $s2, exprtok_left, pos, exprtok_right)
			graphobj.addexpr(varstr)
		}

	} else {

		forsec $o1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(varstr, "%s%s%g%s", secname(), exprtok_left, pos, exprtok_right)
			graphobj.addexpr(varstr)
		}
	}

	graphList[0].append(graphobj)
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
proc chlam() {local k localobj tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) expected number of lamellae, e.g. 16"
			print "2) base multiple for changing this, e.g. 2 or 10"
			print "3) start power range (>= 0), ex: 0"
			print "4) end power range, ex: 6"
			print "5) desired sectionlist (object) or section name (string) to record"
			print "6) variable of interest (string). Ex: \"v\" or \"vext\""
			print "7) optional filename header (string)"
			stop
		}
	}

	tempvec = new Vector(3, 0)

	tempvec.x[0] = Cmy_norm * $1 * 2
	tempvec.x[1] = Rmy_norm/($1 * 2)
	tempvec.x[2] = (smy-1)/($1 * 2)

	for k = 0, $4-$3 {

		Cmy_norm = tempvec.x[0]/(($2^($3+k))*2)
		Rmy_norm = tempvec.x[1] * (($2^($3+k))*2)
		smy = 1 + tempvec.x[2] * (($2^($3+k))*2)

		getpnorm()
		updfitparam(pnormvec)
		init()

		strdef lamstr
		
		sprint(lamstr, "%s%g", "lamellae = ", $2^($3+k))
		
		if (numarg() == 7) {

			sprint(lamstr, "%s%s%s", $s7, ", ", lamstr)

		} else {

			sprint(lamstr, "%s%s", "_", lamstr)			
		}
		
		if (argtype(5) == 2) {

			getsecparam($s5, $s6, lamstr)
	
		} else {

			getsecparam($o5, $s6, lamstr)
		}
	}

	Cmy_norm = tempvec.x[0]/($1 * 2)
	Rmy_norm = tempvec.x[1] * ($1 * 2)
	smy = (tempvec.x[2] * $1 * 2) + 1

	getpnorm()
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta1() {local mpa, mpn, apa, apn, k, delta_pa, delta_pn

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) desired delta_pa (nm)"
			print "2) desired delta_pn (nm)"
			stop
		}
	}

	delta_pa = 12.3
	delta_pn = 7.4

	if (!chgdelta1) {

		dpa = getdiam(interparanodal)
		apa = PI*delta_pa*(1e-7)*(dpa*(1e-4)+delta_pa*(1e-7))
		Rpa = rpa_norm * rpa_low * (1e6) * apa

		dpn = getdiam(paranodal)
		apn = PI*delta_pn*(1e-7)*(dpn*(1e-4)+delta_pn*(1e-7))
		Rpn = rpa_norm * parafact_norm * rpa_low * (1e6) * apn

		rpa_norm_orig = rpa_norm

		chgdelta1 = 1
	}
	
	mpa = $1/delta_pa
	apa = PI*delta_pa*(1e-7)*mpa*(dpa*(1e-4)+delta_pa*(1e-7)*mpa)
	rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
	
	mpn = $2/delta_pn
	apn = PI*delta_pn*(1e-7)*mpn*(dpn*(1e-4)+delta_pn*(1e-7)*mpn)	
	parafact_norm = (((Rpn/apn)*(1e-6))/rpa_low)/rpa_norm_orig

	getpnorm()
	updfitparam(pnormvec)

	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta() {local delta_pa, delta_pn, k

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) desired submyelin space to change the radius of (string), e.g. \"pa\", \"pn\", or \"papn\""
			print "2) base multiple to effect this change, ex: 2, 10, etc"
			print "3) the power range start, ex: -2"
			print "4) the power range end, ex: 3"
			print "5) the desired sectionlist (object) or section name (string) to record"
			print "6) the variable of interest (string), e.g. \"v\" or \"vext\""
			print "7) a file name header (string)"
			stop
		}
	}

	delta_pa = 12.3
	delta_pn = 7.4
	strdef chdelta_header

	for k = 0, $4-$3 {

		if (!strcmp($s1, "pa")) {
			
			chdelta1(($2^($3+k))*delta_pa, delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pa, " nm")
		}

		if (!strcmp($s1, "pn")) {
			
			chdelta1(delta_pn, ($2^($3+k))*delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pn, " nm")
		}

		if (!strcmp($s1, "papn")) {
			
			chdelta1(($2^($3+k))*delta_pa, ($2^($3+k))*delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pa, " nm and ", ($2^($3+k))*delta_pn, " nm")
		}		

		if (argtype(5) == 2) {
		
			getsecparam($s5, $s6, chdelta_header)

		} else {

			getsecparam($o5, $s6, chdelta_header)
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta_pa() {local dpa, dpn, apa, apn, Rpa, Rpn, k, rpa_norm_orig, parafact_norm_orig, Rmy_norm_orig

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) base multiple for changing delta, e.g. 2 or 10"
			print "2 & 3) the power range, e.g. -2, 2"
			print "4) the desired sectionlist to record"
			print "5) the variable of interest. Ex: v or vext"
			print "6) an optional filename header"
			stop
		}
	}

	dpa = getdiam(interparanodal)
	dpn = getdiam(paranodal)
	
	apa = PI*12.3*(1e-7)*(dpa*(1e-4)+12.3*(1e-7))
	apn = PI*7.4*(1e-7)*(dpn*(1e-4)+7.4*(1e-7))
	
	Rpa = rpa_norm * rpa_low * (1e6) * apa
	Rpn = rpa_norm * parafact_norm * rpa_low * (1e6) * apn
	
	Rmy = Rmy_norm * Rmy_low

	rpa_norm_orig = rpa_norm
	parafact_norm_orig = parafact_norm
	Rmy_norm_orig = Rmy_norm

	for k = 0, $3-$2 {

		apa = PI*12.3*(1e-7)*($1^($2+k))*(dpa*(1e-4)+12.3*(1e-7)*($1^($2+k)))
		apn = PI*7.4*(1e-7)*($1^($2+k))*(dpn*(1e-4)+7.4*(1e-7)*($1^($2+k)))

		rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
		parafact_norm = (((Rpn/apn)*(1e-6))/rpa_low)/rpa_norm

		Rmy_norm = (Rmy/((0.5*(dpa+dpn))/((0.5*(dpa+dpn)) + 2*(0.5*(dpa+dpn)*$1^($2+k)))))/Rmy_low

		getpnorm()
		updfitparam(pnormvec)

		sprint(varstr, "%s%g", "new delta *= ", ($1^($2+k)))

		if (numarg() == 6 && argtype(6) == 2) {

			sprint(varstr, "%s%s%s", $s6, ", ", varstr)
		}
		
		getsecparam($s5, $o4, varstr)
	}

	rpa_norm = rpa_norm_orig
	parafact_norm = parafact_norm_orig
	Rmy_norm = Rmy_norm_orig
	
	getpnorm()
	updfitparam(pnormvec)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta_pa() {local ad, apa, Rpa, k, rpa_norm_orig, Rmy_norm_orig

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) an expected delta (nm), e.g. 12.3 Current rpa corresponds to base delta_pa."
			print "2) a base multiple for changing delta, e.g. 2 or 10"
			print "3 & 4) the power range, e.g. -2, 2"
			print "5) the desired sectionlist to record"
			print "6) the variable of interest. Ex: v or vext"
			print "7) an optional filename header"
			stop
		}
	}

	ad = getdiam(internodal)
	apa = PI*12*(1e-7)*(ad*(1e-4)+12*(1e-7))
	Rpa = rpa_norm * rpa_low * (1e6) * apa
	Rmy = Rmy_norm * Rmy_low

	rpa_norm_orig = rpa_norm
	Rmy_norm_orig = Rmy_norm

	for k = 0, $4-$3 {

		apa = PI*12*(1e-7)*(1/12)*(ad*(1e-4)+12*(1e-7)*(1/12))
		rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
		Rmy_norm = (Rmy/(ad/(ad + 2*(12*(1/12)))))/Rmy_low

		getpnorm()
		updfitparam(pnormvec)
		init()

		sprint(varstr, "%s%g%s%g%s", "base delta_pa = ", $1, "nm, new delta_pa = ", $1*($2^($3+k)), "nm")

		if (numarg() == 7 && argtype(7) == 2) {

			sprint(varstr, "%s%s%s", $s7, ", ", varstr)
		}
		
		getsecparam($s6, $o5, varstr)
	}

	rpa_norm = rpa_norm_orig
	Rmy_norm = Rmy_norm_orig
	
	getpnorm()
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chparam() {local k localobj tempvec, paramvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) the parameter of interest (string), e.g. \"Ri\""
			print "2) the base multiple for fold changes, e.g. 2 or 10"
			print "3) the start range of the number of fold changes, e.g. -5"
			print "4) the end range of the number of fold changes, e.g. 5"
			print "5) the desired section name (string) or sectionlist (object) to record, e.g. \"axon[10]\" or axonal"
			print "6) the desired variable to record (string), e.g. \"v\" or \"vext\""
			print "7) an optional file header"

			print "\nHere is the list of available parameters:"
			for k = 0, pnamelist.count-1 print pnamelist.o(k).label
			stop
		}
	}

	tempvec = new Vector(2, 0)

	for k = 0, pnamelist.count-1 {

		if (!strcmp($s1, pnamelist.o(k).label)) {

			tempvec.x[0] = k
			k = pnamelist.count-1
		}
	}
	tempvec.x[1] = pnormvec.x[tempvec.x[0]]

	paramvec = new Vector($4-$3+1, 0)

	for k = 0, $4-$3 {

		paramvec.x[k] = tempvec.x[1] * $2^($3+k)

		pnormvec.x[tempvec.x[0]] = paramvec.x[k]
		updfitparam(pnormvec)
		init()

		strdef header
		
		sprint(header, "%s%s%g%s%s", $s1, "=", ($2^($3+k)), "*", $s1)

		if (numarg() == 7 && argtype(7) == 2) {

			sprint(header, "%s%s%s", $s7, ", ", header)
		}

		if (argtype(5) == 1) {
			
			getsecparam($s6, $o5, header)
		
		} else if (argtype(5) == 2) {

			getsecparam($s6, $s5, header)
		
		} else {

			print "Error: enter the desired section name (string) or sectionlist (object) to record, e.g. \"axon[10]\" or axonal"
			stop
		}
	}

	savepelog()

	pnormvec.x[tempvec.x[0]] = tempvec.x[1]
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getthresh() {local dx localobj tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) time vector"
			print "2) voltage vector"
			print "3) desired dV/dt threshold (V/s)"
			print "Returns threshold onset (time vector units)"
			stop
		}
	}

	dx = ($o1.x[$o1.size-1]-$o1.x[0])/($o1.size-1)

	tempvec = new Vector()

	tempvec.deriv($o2, dx, 1)

	return $o1.x[tempvec.indwhere(">=", $3)]
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdiam() {local k, m localobj diamvec, tempvec, drand

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) sectionlist"
			print "2) diameter slice to add or remove from each measurement in given sectionlist in um (e.g. 0.3 um)"
			stop
		}
	}

	diamvec = new Vector()
	forsec $o1 for (x, 0) diamvec.append(diam(x))

	drand = new Random()
	drand.normal(0, 1)

	tempvec = new Vector()
	for k = 0, diamvec.size-1 tempvec.append(diamvec.x[k] + drand.repick()*$2)

	m = -1
	forsec $o1 for (x, 0) {

		m += 1
		diam(x) = tempvec.x[m]
	}

	print "DIAMETER CHANGE ACTIVATED"
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc randomizep() {local k localobj prand, tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Randomize parameter range (0, np-1) within parameter bound (plow, phi)"
			print "Enter:"
			print "1) start range, i.e. 0 or 8"
			print "2) end range, i.e. getnp()-1"
			print "3) optional: randomization seed (0-n). Default = 0."
			stop
		}
	}

	if (numarg() == 3) {
		
		prand = new Random($3)
	
	} else {
	
		prand = new Random()
	}
	
	tempvec = new Vector()

	getplow()
	getphi()

	for k = $1, $2 {

		prand.uniform(1, phivec.x[k]/plowvec.x[k])
		tempvec.append(prand.repick())
	}

	updfitparam(tempvec, $1, $2)

	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// based on the 3 sigma approach
proc getthresh() {local f, deli, k localobj tempyvec, tempvec

	speedvec = new Vector()

	for f = 0, nf-1 {

		tempyvec = new Vector()

		deli = RegionFitness[f].xdat.indwhere(">=", stim.del)

		for k = 0, deli tempyvec.append(RegionFitness[f].ydat.x[k])

		tempvec = new Vector()

		tempvec.deriv(tempyvec, dt, 1)

		speedvec.append(4*tempvec.stdev())
	}
}
// --------------------------------------------------------------------------------
