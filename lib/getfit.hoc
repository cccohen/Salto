// Salto
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------Variables----------------------------------------
objref paramvec, solnvec, elogvec, plogvec, nefunvec, optibox
objref genvec, spacemat, genvec, mutmat, permvec, chkmat
objref pmat, vvec, rangemat
objref eqlist, pqlist
objref boundvec, origboundlist, newboundlist, weightvec, weightmat, origweightlist, newweightlist, errlist, scalelist
objref drand, diamvec, speedvec, graphobj, prand, krand

solnvec = new Vector()
genvec = new Vector()
spacemat = new Matrix()

elogvec = new Vector()
plogvec = new Vector()
nefunvec = new Vector()

strdef pheader, eheader, vheader, varstr, plogdir, elogdir, logstr, logmatstr, outstr, esimstr, psimstr
strdef mutstart, mutp, mutcom, mutend, mutexec

nefun_ = 0
nquad_ = 0
fitoff = 1
runtime = 0
hourlog = 1
chkhour = 2

// number of genetic divisions into which each paramater's parameter space 
// will be distributed.
nd = 2

esim = -1
psim = -1

newg = 0
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// $1 = mode_
proc adj_injbound() {local f, pifdelt localobj tempxvec

	if (!$1) {
	
		for f = 0, nf-1 {

			if (injvec.x[f]) {

				// search for index in xdat at which x >= pifdel
				pifdelt = RegionFitness[f].xdat.x[RegionFitness[f].xdat.indwhere(">=", getpifdel())]
		
				if (RegionFitness[f].boundary.x[0] < pifdelt) {
		
					RegionFitness[f].boundary.x[0] = pifdelt
					RegionFitness[f].weight.x[0] = 0

					tempxvec = new Vector()
					tempxvec.append(RegionFitness[f].xdat)
					RegionFitness[f].set_modelx(tempxvec)
					
					num = setnsig(pifdelt, 5)
					print "Fit start time adjusted to ", num, "ms for ", FitnessGenerator[0].yvarlist.o(f).s
				}
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// Places a voltage derivative-adjusted weight scale on voltage traces. No arguments.

proc adj_weight() {local points_to_adv, f, k, lo_bound, up_bound, indlo, indhi localobj tempvec, tempxvec, tempyvec, boundvec, weightvec

	points_to_adv = 1/dt/bess
	tempvec = new Vector()
	tempvec.resize(tempvec.size+1)
	tempvec.x[tempvec.size-1] = points_to_adv
	tempvec.floor()
	points_to_adv = tempvec.x[tempvec.size-1]

	for f = 0, nf-1 {

		lo_bound = RegionFitness[f].boundary.x[0]
		up_bound = RegionFitness[f].boundary.x[RegionFitness[f].boundary.size-1]

		tempxvec = new Vector(RegionFitness[f].xdat.size)
		
		for k = 0, tempxvec.size-1 {

			tempxvec.x[k] = RegionFitness[f].xdat.x[k]
		}

		tempyvec = new Vector(RegionFitness[f].ydat.size)
		
		for k = 0, tempyvec.size-1 {

			tempyvec.x[k] = RegionFitness[f].ydat.x[k]
		}

		indlo = tempxvec.indwhere("==", lo_bound)
		indhi = tempxvec.indwhere("==", up_bound)
				
		tempvec = new Vector()
		boundvec = new Vector()

		k = indlo
		while (k <= indhi) {
			
			boundvec.append(tempxvec.x[k])
			tempvec.append(tempyvec.mean(k, k+points_to_adv-1))
			k += points_to_adv			
		}

		boundvec.append(tempxvec.x[indhi])		

		tempvec.deriv(bess*dt, 1)

		tempvec.resize(tempvec.size+1)
		tempvec.x[tempvec.size-1] = tempvec.x[tempvec.size-2]
		
		for k = 0, tempvec.size-1 {

			tempvec.x[k] = abs(tempvec.x[k])
			
			if (tempvec.x[k] < 1) {

				tempvec.x[k] = 1
			}
		}

		weightvec = new Vector()
		weightvec.append(RegionFitness[f].weight.x[0])
		weightvec.append(tempvec)

		RegionFitness[f].boundary = new Vector()
		RegionFitness[f].boundary.append(boundvec)
		
		RegionFitness[f].weight = new Vector()
		RegionFitness[f].weight.append(weightvec)

		RegionFitness[f].set_modelx(tempxvec)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc nopelog() {

	sscanf(elogvec.label, "%lf", &esim)
	sscanf(plogvec.label, "%lf", &psim)

	sprint(esimstr, "%s", elogvec.label)
	sprint(psimstr, "%s", plogvec.label)

	elogvec.label("")
	plogvec.label("")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc pelog() {

	if (!numarg()) {

		sprint(esimstr, "%d", esim)
		sprint(psimstr, "%d", psim)
		
		elogvec.label(esimstr)
		plogvec.label(psimstr)
	}

	if (numarg() == 1) {

		esim = $1
		sprint(esimstr, "%d", esim)
		elogvec.label(esimstr)
	}

	if (numarg() == 2) {

		esim = $1
		sprint(esimstr, "%d", esim)
		elogvec.label(esimstr)

		psim = $2
		sprint(psimstr, "%d", psim)
		plogvec.label(psimstr)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc add_weight() {local f, k, points_to_adv, lo_bound, up_bound, indlo, indhi, nbound, ind, tempnum, m, sizecount localobj tempvec, origboundlist, boundvec, newboundlist, origweightlist, newweightlist, testvec, errlist, scalelist, weightvec	

	points_to_adv = min_weight*(1/dt/bess)
	tempvec = new Vector()
	tempvec.append(points_to_adv)
	tempvec.floor()
	points_to_adv = tempvec.x[0]

	crveclist(nf, origboundlist)
	crveclist(nf, newboundlist)

	crveclist(nf, origweightlist)

	// save original boundary/weight vecs in origbound/origweightlist, and create new boundary vecs in newboundlist
	for f = 0, nf-1 {
			
		origboundlist.o(f).resize(RegionFitness[f].boundary.size)
		
		for k = 0, origboundlist.o(f).size-1 {

			origboundlist.o(f).x[k] = RegionFitness[f].boundary.x[k]
		}

		origweightlist.o(f).resize(RegionFitness[f].weight.size)
		
		for k = 0, origweightlist.o(f).size-1 {

			origweightlist.o(f).x[k] = RegionFitness[f].weight.x[k]
		}

		tempxvec = new Vector(RegionFitness[f].xdat.size)
		
		for k = 0, tempxvec.size-1 {

			tempxvec.x[k] = RegionFitness[f].xdat.x[k]
		}

		lo_bound = origboundlist.o(f).x[0]
		up_bound = origboundlist.o(f).x[origboundlist.o(f).size-1]

		indlo = tempxvec.indwhere("==", lo_bound)
		indhi = tempxvec.indwhere("==", up_bound)		
		
		nbound = (indhi-indlo+1)/points_to_adv
		tempvec = new Vector()
		tempvec.resize(tempvec.size+1)
		tempvec.x[tempvec.size-1] = nbound
		tempvec.floor()
		nbound = tempvec.x[tempvec.size-1]

		if (nbound < min_weight) {

			print "add_weight() cannot be used for fit variable ", f, "because nbound = ", nbound, " is too low or min_weight = ", min_weight, " is too high..."
			print "Consider increasing the total range of weight intervals..."
			stop
		}

		boundvec = new Vector()
		boundvec.resize(boundvec.size+1)
		boundvec.x[boundvec.size-1] = tempxvec.x[indlo]

		k = indlo
		while (k <= indhi) {

			boundvec.resize(boundvec.size+1)
			boundvec.x[boundvec.size-1] = tempxvec.x[k+points_to_adv-1]
			k += points_to_adv
		}

		if (boundvec.size < nbound+1) {

			boundvec.resize(boundvec.size+1)
			boundvec.x[boundvec.size+1] = tempxvec.x[indhi]
		}

		newboundlist.o(f).resize(boundvec.size)
		
		for k = 0, newboundlist.o(f).size-1 {

			newboundlist.o(f).x[k] = boundvec.x[k]
		}
	}
	
	// create new weight vecs in newweightlist
	tempnum = 0
	
	for f = 0, nf-1 {

		tempnum += newboundlist.o(f).size
	}

	crveclist(tempnum-nf, newweightlist)

	for f = 0, nf-1 {

		weightmat = new Matrix(newboundlist.o(f).size, newboundlist.o(f).size-1)
		
		for k = 0, weightmat.ncol-1 {

			weightmat.x[0][k] = origweightlist.o(f).x[0]
		}

		weightvec = new Vector(weightmat.nrow, 0)
		weightvec.x[0] = origweightlist.o(f).x[0]

		weightvec.x[1] = 1
		weightmat.setcol(0, weightvec)

		k = 1
		while (k <= weightmat.ncol-1) {

			if (weightvec.x[k] == 1) {

				weightvec.x[k] = 0
				weightvec.x[k+1] = 1
				weightmat.setcol(k, weightvec)
			}

			k += 1
		}

		for k = 0, weightmat.ncol-1 {

			newweightlist.o(f*weightmat.ncol+k).resize(weightmat.nrow)
			
			for m = 0, newweightlist.o(f*weightmat.ncol+k).size-1 {

				newweightlist.o(f*weightmat.ncol+k).x[m] = weightmat.x[m][k]
			}
		}
	}

	// create a list containing the errors from each newboundlist and newweightlist combination
	crveclist(nf, errlist)
	
	// size-1 because not counting the first bound/weight, which is always 0
	for k = 0, errlist.count-1 {

		errlist.o(k).resize(newboundlist.o(k).size-1)
	}

	// determine if all new weightvecs will be of equal size, to save time
	testvec = new Vector(newboundlist.count)
	
	for k = 0, testvec.size-1 {

		testvec.x[k] = newboundlist.o(k).size-1
	}
	
	tempnum = 0
	
	for k = 0, testvec.size-2 {

		if (testvec.x[k] == testvec.x[k+1]) {

			tempnum += 1
		}
	}

	if (tempnum == testvec.size-1) {
	
		print "Add weight activated (one run per interval)..."

		for m = 0, newboundlist.o(0).size-2 {

			for f = 0, nf-1 {

				RegionFitness[f].boundary = new Vector(newboundlist.o(f).size)
				
				for k = 0, RegionFitness[f].boundary.size-1 {

					RegionFitness[f].boundary.x[k] = newboundlist.o(f).x[k]
				}
					
				RegionFitness[f].weight = new Vector(newweightlist.o(f*(newboundlist.o(0).size-1)+m).size)
				
				for k = 0, RegionFitness[f].weight.size-1 {

					RegionFitness[f].weight.x[k] = newweightlist.o(f*(newboundlist.o(0).size-1)+m).x[k]
				}				

				tempxvec = new Vector(RegionFitness[f].xdat.size)
				
				for k = 0, tempxvec.size-1 {

					tempxvec.x[k] = RegionFitness[f].xdat.x[k]
				}

				RegionFitness[f].set_modelx(tempxvec)
			}

			print "Checking interval ", m+1, "of ", newboundlist.o(0).size-1
			nopelog()
			FitnessGenerator[0].efun()
			pelog()

			for k = 0, errlist.count-1 {

				errlist.o(k).x[m] = RegionFitness[k].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(k), RegionFitness[k].dw_)
			}
		}
	
	} else {
	
		print "Add weight activated (one run per interval per fit variable)..."

		sizecount = 0

		for f = 0, nf-1 {

			sizecount += newboundlist.o(f).size-1
			
			for k = sizecount-(newboundlist.o(f).size-1), sizecount-1 {

				RegionFitness[f].boundary = new Vector(newboundlist.o(f).size)
				
				for m = 0, RegionFitness[f].boundary.size-1 {

					RegionFitness[f].boundary.x[m] = newboundlist.o(f).x[m]
				}
				
				RegionFitness[f].weight = new Vector(newweightlist.o(k).size)
				
				for m = 0, RegionFitness[f].weight.size-1 {

					RegionFitness[f].weight.x[m] = newweightlist.o(k).x[m]
				}

				tempxvec = new Vector(RegionFitness[f].xdat.size)
				
				for m = 0, tempxvec.size-1 {

					tempxvec.x[m] = RegionFitness[f].xdat.x[m]
				}

				RegionFitness[f].set_modelx(tempxvec)

				print "Checking interval ", k+1, "of ", testvec.sum
				nopelog()
				FitnessGenerator[0].efun()
				pelog()

				errlist.o(f).x[k] = RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_)
			}
		}
	}

	// calculate ratio of weight to scale for each time/bound interval, and place these in scalelist.
	crveclist(errlist.count, scalelist)
	
	for k = 0, scalelist.count-1 {

		scalelist.o(k).resize(errlist.o(k).size)
	}

	// append minimum errors from each fit variable's error run over the selected intervals
	tempvec = new Vector(errlist.count)
	
	for k = 0, tempvec.size-1 {

		tempvec.x[k] = errlist.o(k).min
	}

	// calculate ratio to min error
	for k = 0, scalelist.count-1 {

		for m = 0, scalelist.o(k).size-1 {

			scalelist.o(k).x[m] = errlist.o(k).x[m]/tempvec.x[k]
		}
	}

	// apply the new weight scale
	for f = 0, nf-1 {

		RegionFitness[f].weight = new Vector(scalelist.o(f).size+1)
		RegionFitness[f].boundary = new Vector(newboundlist.o(f).size)

		for k = 1, RegionFitness[f].weight.size-1 {

			RegionFitness[f].weight.x[k] = scalelist.o(f).x[k-1]
		}

		for k = 0, RegionFitness[f].boundary.size-1 {

			RegionFitness[f].boundary.x[k] = newboundlist.o(f).x[k]
		}

		tempxvec = new Vector(RegionFitness[f].xdat.size)

		for k = 0, tempxvec.size-1 {

			tempxvec.x[k] = RegionFitness[f].xdat.x[k]
		}		

		RegionFitness[f].set_modelx(tempxvec)
	}

	initfit()

	print "add weight ended..."
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getnp() {

	return ParmFitness[0].parmlist.count()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getpheader() {local p

	sprint(pheader, "%s", "")
	
	for p = 0, pnamelist.count-1 {

		sprint(pheader, "%s%s\t", pheader, pnamelist.o(p).label)
	}
	
	sprint(pheader, "%s\n", pheader)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc geteheader() {local f
	
	// construct emat/elogmat header
	// each col fitvar name, then col total, then tol
	sprint(eheader, "%s", "")
	
	for f = 0, nf-1 {

		sprint(eheader, "%s%s\t", eheader, fitvarlist.o(f).label)
	}
	
	sprint(eheader, "%s\t%s\t%s\n", eheader, "total", "tol")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getvheader() {local f, k

	// construct vmat header
	// col0 = time, col1,...,coln = v(fit variables)
	sprint(vheader, "%s", "time")
	
	for k = 0, $1-1 {

		for f = 0, nf-1 {

			sprint(vheader, "%s\t%s", vheader, fitvarlist.o(f).label)
		}
	}
	
	sprint(vheader, "%s\n", vheader)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getpnnheader() {local p

	sprint(pnnheader, "%s", "")
	
	for p = 0, pnamelist.count-1 {

		sprint(pnnheader, "%s%s%s\t", pnnheader, pnamelist.o(p).label, "_nn")
	}
	
	sprint(pnnheader, "%s\n", pnnheader)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc initfit() {

	elogvec.resize(0)
	plogvec.resize(0)
	nefunvec.resize(0)

	chkmat = crchkmat()

	nefun_ = 0
	nquad_ = 0
	runtime = 0
	hourlog = 1
	chkhour = 2
	fitoff = 1
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
proc updparampanel() {local p

	for p = 0, getnp()-1 {

		pvec.x[p] = RunFitParm[p].val * plowvec.x[p]
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func chktime() {localobj krand

	krand = new Random()

	if (runtime >= hourlog * krand.uniform($1*3600, $2*3600)) {

		hourlog += 1

		return 1
	
	} else {

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// update error and parameter log. REQUIRES A MINIMUM OF 1 FIT RUN 
// WITH THE PARAMETERS OF CHOICE to record these, as well as their corresponding error.

proc updpelog() {local f, p, ydatsize, yfitsize

	if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

		ydatsize = 0
		yfitsize = 0

		for f = 0, nf-1 {

			ydatsize += RegionFitness[f].ydat_.size
			yfitsize += FitnessGenerator[0].yveclist.o(f).size
		}

		if (ydatsize == yfitsize) {

			elogvec.resize(elogvec.size+nf+1)

			for f = 0, nf-1 {

				elogvec.x[elogvec.size-(nf+1)+f] = RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_)
				elogvec.x[elogvec.size-1] += elogvec.x[elogvec.size-(nf+1)+f]
			}

			plogvec.resize(plogvec.size+getnp())

			for p = 0, getnp()-1 {

				plogvec.x[plogvec.size-getnp()+p] = RunFitParm[p].val
			}

			if (chktime(chkhour, chkhour+0.2)) {

				savepelog()
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc savepelog() {local k localobj tempvec

	if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

		sscanf(elogvec.label, "%lf", &esim)
		sscanf(plogvec.label, "%lf", &psim)

		if (getiampdir()) {

			if (elogvec.size && plogvec.size) {

				if (chkdir(iampdir, "elog") && chkdir(iampdir, "plog")) {

					sprint(elogdir, "%s%s", iampdir, "elog/")
					sprint(plogdir, "%s%s", iampdir, "plog/")
									
					sprint(format, "%s%s", "%s", vformvec)

					sprint(outstr, "%s", "")

					// save elog
					for k = 0, elogvec.size-1 {

						sprint(outstr, format, outstr, elogvec.x[k])
					}

					elogvec.resize(0)

					sprint(filestr, "%d%s", esim, ".dat")

					writestr(elogdir, filestr, outstr, 1)

					sprint(outstr, "%s", "")

					sprint(format, "%s%s", "%s", maxformvec)

					// save plog
					for k = 0, plogvec.size-1 {

						sprint(outstr, format, outstr, plogvec.x[k])
					}

					plogvec.resize(0)

					sprint(filestr, "%d%s", psim, ".dat")

					writestr(plogdir, filestr, outstr, 1)

					sprint(outstr, "%s", "")
				
				} else {

					crdir(iampdir, "elog")
					crdir(iampdir, "plog")

					savepelog()
				}
			
			} else {

				if (!chkdir(iampdir, "elog") && !chkdir(iampdir, "plog")) {

					crdir(iampdir, "elog")
					crdir(iampdir, "plog")
				}
			}
		
		} else {

			if (chkdir(root, "out")) {

				getmod()

				if (chkdir(out, modstr)) {

					crdir(moddir, iampstr)
					savepelog()
				
				} else {

					crdir(out, modstr)
					savepelog()
				}
			
			} else {

				crdir(root, "out")
				savepelog()
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getpelogdirs() {

	if (numarg() == 0) {

		getiampdir()
		sprint(elogdir, "%s%s", iampdir, "elog/")
		sprint(plogdir, "%s%s", iampdir, "plog/")
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getmodeltype() {local rec, SOf, AXf, DEf

	sprint(modeltypestr, "%s", "")
	DEFAULT = 0

	if ($2) {

		// count locations
		SOf = 0
		AXf = 0
		DEf = 0

		sprint(SOstr, "%s", "soma")
		sprint(AXstr, "%s", "axon")
		sprint(DEstr, "%s", "dend")
		sprint(APstr, "%s", "apic")

		// define number and location of recordings
		for rec = 0, nrec-1 {

			if (strf.substr(recloclist.o(rec).label, SOstr) > -1) {
			
				SOf += 1
			
			} else if (strf.substr(recloclist.o(rec).label, AXstr) > -1) {
			
				AXf += 1
			
			} else if ((strf.substr(recloclist.o(rec).label, DEstr) > -1) || (strf.substr(recloclist.o(rec).label, APstr) > -1)) {

				DEf += 1
			}
		}

		// labels for combination of fit variables
		SOAX = 0
		SODE = 0
		SO = 0
		AX = 0
		DE = 0		

		// Establish model type as a function of fit variable locations
		if (SOf > 0 && AXf > 0 && DEf == 0) {

			SOAX = 1
			modeltypestr = "SOAX"

			if ($1 == 0) {

				Ri_doarg = 1
				Ri_uselog = 1
				
				rpa_doarg = 1
				rpa_uselog = 1
				
				parafact_doarg = 1
				parafact_uselog = 1
				
				Rm_doarg = 1
				Rm_uselog = 1

				Rmy_doarg = 1
				Rmy_uselog = 1
				
				Cm_doarg = 1
				Cm_uselog = 1
				
				Cmy_doarg = 1
				Cmy_uselog = 1
				
				Cpip_doarg = 1
				Cpip_uselog = 1

				
				Na_so_doarg = 0
				Na_so_uselog = 0

				lc_Na_de_doarg = 0
				lc_Na_de_uselog = 0

				Na_prox_doarg = 0
				Na_prox_uselog = 0

				Na_ais_doarg = 0
				Na_ais_uselog = 0

				Na_int_doarg = 0
				Na_int_uselog = 0

				Na_nod_doarg = 0
				Na_nod_uselog = 0

				Na_end_doarg = 0
				Na_end_uselog = 0

				Na_col_doarg = 0
				Na_col_uselog = 0


				Nap_ais_doarg = 0
				Nap_ais_uselog = 0

				Nap_int_doarg = 0
				Nap_int_uselog = 0

				Nap_nod_doarg = 0
				Nap_nod_uselog = 0

				Nap_end_doarg = 0
				Nap_end_uselog = 0


				Kv1_so_doarg = 0
				Kv1_so_uselog = 0

				lc_Kv_Kv1_de_doarg = 0
				lc_Kv_Kv1_de_uselog = 0

				Kv1_prox_doarg = 0
				Kv1_prox_uselog = 0

				Kv1_ais_doarg = 0
				Kv1_ais_uselog = 0

				Kv1_int_doarg = 0
				Kv1_int_uselog = 0

				Kv1_nod_doarg = 0
				Kv1_nod_uselog = 0

				Kv1_end_doarg = 0
				Kv1_end_uselog = 0

				Kv1_col_doarg = 0
				Kv1_col_uselog = 0


				Kv_so_doarg = 0
				Kv_so_uselog = 0


				Kv7_de_doarg = 0
				Kv7_de_uselog = 0

				Kv7_so_doarg = 0
				Kv7_so_uselog = 0

				Kv7_prox_doarg = 0
				Kv7_prox_uselog = 0

				Kv7_ais_doarg = 0
				Kv7_ais_uselog = 0

				Kv7_int_doarg = 0
				Kv7_int_uselog = 0

				Kv7_nod_doarg = 0
				Kv7_nod_uselog = 0

				Kv7_end_doarg = 0
				Kv7_end_uselog = 0

				Kv7_col_doarg = 0
				Kv7_col_uselog = 0


				KCa_doarg = 0
				KCa_uselog = 0


				Ca_doarg = 0
				Ca_uselog = 0

				It2_doarg = 0
				It2_uselog = 0


				H_so_doarg = 0
				H_so_uselog = 0

				tc_H_de_doarg = 0
				tc_H_de_uselog = 0

				H_ax_doarg = 0
				H_ax_uselog = 0


				Kv1_juxta_doarg = 0
				Kv1_juxta_uselog = 0
			}

			if ($1 == 1) {

				Ri_doarg = 0
				Ri_uselog = 0
				
				rpa_doarg = 0
				rpa_uselog = 0
				
				parafact_doarg = 0
				parafact_uselog = 0
				
				Rm_doarg = 0
				Rm_uselog = 0

				Rmy_doarg = 0
				Rmy_uselog = 0
				
				Cm_doarg = 0
				Cm_uselog = 0
				
				Cmy_doarg = 0
				Cmy_uselog = 0
				
				Cpip_doarg = 0
				Cpip_uselog = 0

				
				Na_so_doarg = 1
				Na_so_uselog = 1

				lc_Na_de_doarg = 1
				lc_Na_de_uselog = 1

				Na_prox_doarg = 1
				Na_prox_uselog = 1

				Na_ais_doarg = 1
				Na_ais_uselog = 1

				Na_int_doarg = 1
				Na_int_uselog = 1

				Na_nod_doarg = 1
				Na_nod_uselog = 1

				Na_end_doarg = 1
				Na_end_uselog = 1

				Na_col_doarg = 1
				Na_col_uselog = 1


				Nap_ais_doarg = 1
				Nap_ais_uselog = 1

				Nap_int_doarg = 1
				Nap_int_uselog = 1

				Nap_nod_doarg = 1
				Nap_nod_uselog = 1

				Nap_end_doarg = 1
				Nap_end_uselog = 1


				Kv1_so_doarg = 1
				Kv1_so_uselog = 1

				lc_Kv_Kv1_de_doarg = 1
				lc_Kv_Kv1_de_uselog = 1

				Kv1_prox_doarg = 1
				Kv1_prox_uselog = 1

				Kv1_ais_doarg = 1
				Kv1_ais_uselog = 1

				Kv1_int_doarg = 1
				Kv1_int_uselog = 1

				Kv1_nod_doarg = 1
				Kv1_nod_uselog = 1

				Kv1_end_doarg = 1
				Kv1_end_uselog = 1

				Kv1_col_doarg = 1
				Kv1_col_uselog = 1


				Kv_so_doarg = 1
				Kv_so_uselog = 1


				Kv7_de_doarg = 1
				Kv7_de_uselog = 1

				Kv7_so_doarg = 1
				Kv7_so_uselog = 1

				Kv7_prox_doarg = 1
				Kv7_prox_uselog = 1

				Kv7_ais_doarg = 1
				Kv7_ais_uselog = 1

				Kv7_int_doarg = 1
				Kv7_int_uselog = 1

				Kv7_nod_doarg = 1
				Kv7_nod_uselog = 1

				Kv7_end_doarg = 1
				Kv7_end_uselog = 1

				Kv7_col_doarg = 1
				Kv7_col_uselog = 1


				KCa_doarg = 1
				KCa_uselog = 1


				Ca_doarg = 1
				Ca_uselog = 1

				It2_doarg = 1
				It2_uselog = 1


				H_so_doarg = 1
				H_so_uselog = 1

				tc_H_de_doarg = 1
				tc_H_de_uselog = 1

				H_ax_doarg = 1
				H_ax_uselog = 1

				if (juxtaparanod) {

					Kv1_juxta_doarg = 1
					Kv1_juxta_uselog = 1
				}
			}

			if (numarg() == 3 && argtype(3) == 0) {

				if ($3 == 1) {

					print SOf, "somatic and ", AXf, "axonal recording locations found"
				}				
			}

		} else if (SOf > 0 && DEf > 0 && AXf == 0) {

			SODE = 1
			modeltypestr = "SODE"

			if ($1 == 0) {

				Ri_doarg = 1
				Ri_uselog = 1
				
				rpa_doarg = 0
				rpa_uselog = 0
				
				parafact_doarg = 0
				parafact_uselog = 0
				
				Rm_doarg = 1
				Rm_uselog = 1

				Rmy_doarg = 0
				Rmy_uselog = 0
				
				Cm_doarg = 1
				Cm_uselog = 1
				
				Cmy_doarg = 0
				Cmy_uselog = 0
				
				Cpip_doarg = 1
				Cpip_uselog = 1

				
				Na_so_doarg = 0
				Na_so_uselog = 0

				lc_Na_de_doarg = 0
				lc_Na_de_uselog = 0

				Na_prox_doarg = 0
				Na_prox_uselog = 0

				Na_ais_doarg = 0
				Na_ais_uselog = 0

				Na_int_doarg = 0
				Na_int_uselog = 0

				Na_nod_doarg = 0
				Na_nod_uselog = 0

				Na_end_doarg = 0
				Na_end_uselog = 0

				Na_col_doarg = 0
				Na_col_uselog = 0


				Nap_ais_doarg = 0
				Nap_ais_uselog = 0

				Nap_int_doarg = 0
				Nap_int_uselog = 0

				Nap_nod_doarg = 0
				Nap_nod_uselog = 0

				Nap_end_doarg = 0
				Nap_end_uselog = 0


				Kv1_so_doarg = 0
				Kv1_so_uselog = 0

				lc_Kv_Kv1_de_doarg = 0
				lc_Kv_Kv1_de_uselog = 0

				Kv1_prox_doarg = 0
				Kv1_prox_uselog = 0

				Kv1_ais_doarg = 0
				Kv1_ais_uselog = 0

				Kv1_int_doarg = 0
				Kv1_int_uselog = 0

				Kv1_nod_doarg = 0
				Kv1_nod_uselog = 0

				Kv1_end_doarg = 0
				Kv1_end_uselog = 0

				Kv1_col_doarg = 0
				Kv1_col_uselog = 0


				Kv_so_doarg = 0
				Kv_so_uselog = 0


				Kv7_de_doarg = 0
				Kv7_de_uselog = 0

				Kv7_so_doarg = 0
				Kv7_so_uselog = 0

				Kv7_prox_doarg = 0
				Kv7_prox_uselog = 0

				Kv7_ais_doarg = 0
				Kv7_ais_uselog = 0

				Kv7_int_doarg = 0
				Kv7_int_uselog = 0

				Kv7_nod_doarg = 0
				Kv7_nod_uselog = 0

				Kv7_end_doarg = 0
				Kv7_end_uselog = 0

				Kv7_col_doarg = 0
				Kv7_col_uselog = 0


				KCa_doarg = 0
				KCa_uselog = 0


				Ca_doarg = 0
				Ca_uselog = 0

				It2_doarg = 0
				It2_uselog = 0


				H_so_doarg = 0
				H_so_uselog = 0

				tc_H_de_doarg = 0
				tc_H_de_uselog = 0

				H_ax_doarg = 0
				H_ax_uselog = 0


				Kv1_juxta_doarg = 0
				Kv1_juxta_uselog = 0
			}

			if ($1 == 1) {

				Ri_doarg = 0
				Ri_uselog = 0
				
				rpa_doarg = 0
				rpa_uselog = 0
				
				parafact_doarg = 0
				parafact_uselog = 0
				
				Rm_doarg = 0
				Rm_uselog = 0

				Rmy_doarg = 0
				Rmy_uselog = 0
				
				Cm_doarg = 0
				Cm_uselog = 0
				
				Cmy_doarg = 0
				Cmy_uselog = 0
				
				Cpip_doarg = 0
				Cpip_uselog = 0

				
				Na_so_doarg = 1
				Na_so_uselog = 1

				lc_Na_de_doarg = 1
				lc_Na_de_uselog = 1

				Na_prox_doarg = 1
				Na_prox_uselog = 1

				Na_ais_doarg = 1
				Na_ais_uselog = 1

				Na_int_doarg = 0
				Na_int_uselog = 0

				Na_nod_doarg = 0
				Na_nod_uselog = 9

				Na_end_doarg = 0
				Na_end_uselog = 0

				Na_col_doarg = 0
				Na_col_uselog = 0


				Nap_ais_doarg = 1
				Nap_ais_uselog = 1

				Nap_int_doarg = 0
				Nap_int_uselog = 0

				Nap_nod_doarg = 0
				Nap_nod_uselog = 0

				Nap_end_doarg = 0
				Nap_end_uselog = 0


				Kv1_so_doarg = 1
				Kv1_so_uselog = 1

				lc_Kv_Kv1_de_doarg = 1
				lc_Kv_Kv1_de_uselog = 1

				Kv1_prox_doarg = 1
				Kv1_prox_uselog = 1

				Kv1_ais_doarg = 1
				Kv1_ais_uselog = 1

				Kv1_int_doarg = 0
				Kv1_int_uselog = 0

				Kv1_nod_doarg = 0
				Kv1_nod_uselog = 0

				Kv1_end_doarg = 0
				Kv1_end_uselog = 0

				Kv1_col_doarg = 0
				Kv1_col_uselog = 0


				Kv_so_doarg = 1
				Kv_so_uselog = 1


				Kv7_de_doarg = 1
				Kv7_de_uselog = 1

				Kv7_so_doarg = 1
				Kv7_so_uselog = 1

				Kv7_prox_doarg = 1
				Kv7_prox_uselog = 1

				Kv7_ais_doarg = 1
				Kv7_ais_uselog = 1

				Kv7_int_doarg = 0
				Kv7_int_uselog = 0

				Kv7_nod_doarg = 0
				Kv7_nod_uselog = 0

				Kv7_end_doarg = 1
				Kv7_end_uselog = 1

				Kv7_col_doarg = 1
				Kv7_col_uselog = 1


				KCa_doarg = 1
				KCa_uselog = 1


				Ca_doarg = 1
				Ca_uselog = 1

				It2_doarg = 1
				It2_uselog = 1


				H_so_doarg = 1
				H_so_uselog = 1

				tc_H_de_doarg = 1
				tc_H_de_uselog = 1

				H_ax_doarg = 1
				H_ax_uselog = 1

				Kv1_juxta_doarg = 0
				Kv1_juxta_uselog = 0
			}

			if (numarg() == 3 && argtype(3) == 0) {

				if ($3 == 1) {

					print SOf, "somatic and ", DEf, "dendritic recording locations found"
				}
			}

		} else if (SOf > 0 && AXf == 0 && DEf == 0) {

			SO = 1
			modeltypestr = "SO"

			Ri_doarg = 1
			rpa_doarg = 0
			parafact_doarg = 0
			Rm_doarg = 1
			Rmy_doarg = 0
			Cm_doarg = 1
			Cmy_doarg = 0
			Cpip_doarg = 1

			if (numarg() == 3 && argtype(3) == 0) {

				if ($3 == 1) {

					print SOf, "somatic recording location(s) found"
				}
			}
		}
	
	} else {

		DEFAULT = 1
		modeltypestr = "DEFAULT"
	}

	if ($1 == 0) {

		sprint(modeltypestr, "%s%s%s", "pas", "-", modeltypestr)
	
	} else if ($1 == 1) {

		sprint(modeltypestr, "%s%s%s", "act", "-", modeltypestr)
	}

	// to modify from defaults, and take into account extra parameters, if any.
	loadfile(ses, doargfilestr)

	if ($2) {

		if (RmN_doarg) {

			sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RmN")
		}
		
		if (RmA_doarg) {

			sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RmA")
		}

		if (RmI_doarg) {

			sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RmI")
		}

		if (RiA_doarg) {

			sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "RiA")
		}

		if (per_int_doarg) {
		
			sprint(modeltypestr, "%s%s%s", modeltypestr, "-", "perint")
			initperint()
		}
	}

	if (numarg() == 3 && argtype(3) == 0) {

		if ($3 == 0 || $3 == 1) {

			print "Model type: ", modeltypestr
		}			
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// updates both pnorm and corresponding RunFitParm with pnorm arguments
proc updfitparam() {local p, i, k

	if (argtype(1) == 1) {

		// whole vector input
		if (numarg() == 1) {

			if (argtype(1) == 1) {

				for p = 0, $o1.size-1 {

					RunFitParm[p].val = $o1.x[p]
					setpnorm(p, $o1.x[p])
				}
			}

		// vector + vector range from $2 to $3 as input 
		} else if (numarg() == 3) {

			if (argtype(1) == 1) {

				for k = 0, $o1.size-1 {

					RunFitParm[k+$2].val = $o1.x[k]
					setpnorm(k+$2, $o1.x[k])
				}
			}
		}
	
	// input as individual parameters 
	} else {

		for i = 1, numarg() {

			RunFitParm[i-1].val = $i
			setpnorm(i-1, $i)
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// check number of RunFitParm variables against number that should be present, 
// based on setnp(), and fixes these accordingly. Should be run once before opts.

proc updrfp() {local k, tempnum

	getpnorm()
	getplow()
	getphi()
	getdoarg()
	getuselog()

	tempnum = ParmFitness[0].parmlist.count

	for k = 0, pnormvec.size-1 {

		if (k < tempnum) {

			sprint(tempstr, "%s%s", pnamelist.o(k).label, "_norm")
			
			if (uselogvec.x[k]) {
			
				ParmFitness[0].parmlist.o(k).set(tempstr, pnormvec.x[k], 1, phivec.x[k]/plowvec.x[k], doargvec.x[k], uselogvec.x[k])
			
			} else {
			
				if (plowvec.x[k] < 0 && phivec.x[k] >= 0) {
			
					ParmFitness[0].parmlist.o(k).set(tempstr, pnormvec.x[k], phivec.x[k]/plowvec.x[k], 1, doargvec.x[k], uselogvec.x[k])
				}
			}

			tempobj = ParmFitness[0].parmlist.o(k)
			tempobj.setname(tempstr)
			ParmFitness[0].parmlist.remove(k)
			ParmFitness[0].parmlist.insrt(k, tempobj)
			objref tempobj
			objref domainbox, domainlist, parmbox

		} else {

			sprint(tempstr, "%s%s", pnamelist.o(k).label, "_norm")			
			tempobj = new RunFitParm(tempstr)

			if (uselogvec.x[k]) {
			
				tempobj.set(tempstr, pnormvec.x[k], 1, phivec.x[k]/plowvec.x[k], doargvec.x[k], uselogvec.x[k])
			
			} else {
			
				if (plowvec.x[k] < 0 && phivec.x[k] >= 0) {
			
					tempobj.set(tempstr, pnormvec.x[k], phivec.x[k]/plowvec.x[k], 1, doargvec.x[k], uselogvec.x[k])
				}
			}
			
			ParmFitness[0].declare(tempobj)
			ParmFitness[0].parmlist.append(tempobj)
			objref domainbox, domainlist, parmbox
			
			if (strf.head(tempstr, "\\$", teststr) == -1) {

				sprint(tempstr, "%s", "")
				sprint(tempstr, "%s.val = %s", tempobj, tempstr)
				execute1(tempstr)
			}
		}
	}

	if (pnormvec.size < ParmFitness[0].parmlist.count) {

		tempnum = ParmFitness[0].parmlist.count - pnormvec.size

		k = 0
		while (k < tempnum) {

			ParmFitness[0].parmlist.remove(ParmFitness[0].parmlist.count-1)
			objref domainbox, domainlist, parmbox
			k += 1
		}
	}

	ParmFitness[0].def_parmlist_use()

	objref tempobj
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc initpnormdef() {local p

	for p = 0, getnp()-1 {

		RunFitParm[p].val = pnormdefvec.x[p]
		setpnorm(p, pnormdefvec.x[p])
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc showdom() {

	ParmFitnessGui[0].showdomain(1637.9, 724, 218.74, 213.12)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// set to-be-optimized genes, i.e. parameters.
proc setgen() {local p, tempnum

	genvec.resize(0)

	if (mode_ == 0) {

		getmodeltype(mode_, idata)
		getdoarg()

		for p = 0, doargvec.size-2 {

			if (doargvec.x[p]) {

				genvec.resize(genvec.size+1)
				genvec.x[genvec.size-1] = p
			}
		}
	
	} else if (mode_ == 1) {

		if (SOAX && axbleb_exists) {
			
			tempnum = setnp(0)
			setnp(mode_)

			genvec.resize(11)
			
			// Selected parameters
			// Na: so, ais, nod, end
			// Kv1: so, ais, nod, end
			// if juxta: Kv1 juxta
			// Kv: so

			// Na_so
			genvec.x[0] = tempnum+0
			// Na_ais
			genvec.x[1] = tempnum+3
			// Na_int
			genvec.x[2] = tempnum+4
			// Na_nod
			genvec.x[3] = tempnum+5
			// Na_end
			genvec.x[4] = tempnum+6

			// Kv1_so
			genvec.x[5] = tempnum+12
			// Kv1_ais
			genvec.x[6] = tempnum+15
			// Kv1_int
			genvec.x[7] = tempnum+16
			// Kv1_nod
			genvec.x[8] = tempnum+17
			// Kv1_end
			genvec.x[9] = tempnum+18

			// Kv_so
			genvec.x[10] = tempnum+20

			// Kv1_juxta
			if (juxtaparanod) {

				genvec.resize(genvec.size+1)
				genvec.x[genvec.size-1] = tempnum+35
			}
		}
	}
	
	ns = nd^(genvec.size)
}
// --------------------------------------------------------------------------------



// ---------------------------------------------------------------------------------------
// delimit the domains in parameter space, from which a randomly chosen base, 
// or initial condition, will be mutated and expressed. Excludes the very weakly-constrained 
// Cpip, which will still be optimized, but as a "silent" gene.

proc spacegen() {local m, p

	getphi()
	getplow()
	
	spacemat.resize(nd+1, genvec.size)

	for m = 0, spacemat.nrow-1 {
			
		for p = 0, spacemat.ncol-1 {

			spacemat.x[m][p] = 1 + m*(((phivec.x[genvec.x[p]]/plowvec.x[genvec.x[p]])-1)/nd)
		}
	}
}
// ---------------------------------------------------------------------------------------



// ---------------------------------getmutation-------------------------------------------
// procedure for getting  mutation possibilities, which are really just
// permutations of all possible pspace row indices (row = 0, row = nrow-2).
// i.e. if nd = 2, there are 2 possible pspace rows indices, representing
// the 2 states of the variable: (row = 0, row = 1) and (row = 1, row = 2).

proc getmutation() {local k localobj tempvec

	tempvec = new Vector(genvec.size, 0)
	mutmat = new Matrix(ns, tempvec.size)

	if (nd == 1) {

		for k = 0, mutmat.nrow-1 {

			mutmat.setrow(k, tempvec)
		}

	} else {

		mutsim = 0
		sprint(mutstart, "%s", "")
		sprint(mutp, "%s", "")
		sprint(mutend, "%s", "")

		for k = 0, tempvec.size-1 {

			sprint(mutstart, "%s%s%d%s", mutstart, "for p", k, " = 0, nd-1 {\n")
			sprint(mutp, "%s%s%d%s", mutp, "p", k, ",")
			sprint(mutend, "%s%s", mutend, "}\n")
		}

		strf.left(mutp, strf.len(mutp)-1)
		sprint(mutcom, "%s%s%s", "permvec = new Vector()\npermvec.append(", mutp, ")\nmutmat.setrow(mutsim, permvec)\nmutsim+=1\n")
		sprint(mutexec, "%s%s%s", mutstart, mutcom, mutend)
		execute(mutexec)

		mutsim = 0
		sprint(mutstart, "%s", "")
		sprint(mutp, "%s", "")
		sprint(mutend, "%s", "")
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc crchkmat() {local m

	// chkmat created and sized to current number of fit parameters, 
	// and initialized to all parameters being non-optimal (=1) 
	// and therefore eligible for further optimization
	chkmat = new Matrix(getnp(), 1)

	for m = 0, chkmat.nrow-1 {

		chkmat.x[m][0] = 1
	}

	// remove eligibility from already optimal or currently non-optimized parameters (in increasing order of parameter numbers)
	if (solnvec.size) {

		for m = 0, solnvec.size-1 {

			chkmat.x[m][0] = 0
		}
	}

	if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

		if (esim == -1 && psim == -1) {

			for m = 0, chkmat.nrow-1 {

				chkmat.x[m][0] = 0
			}
		}
	}

	getmodeltype(mode_, idata)
	getdoarg()
	for m = 0, chkmat.nrow-1 {

		if (!doargvec.x[m]) {

			chkmat.x[m][0] = 0
		}
	}

	return chkmat
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc chkparam() {local m, tempnum, p

	$o1.resize($o1.nrow, 3)

	getplow()
	getphi()

	for m = 0, $o1.nrow-1 {

		if ($o1.x[m][0]) {

			$o1.x[m][1] = 1
			$o1.x[m][2] = phivec.x[m]/plowvec.x[m]
		}
	}

	if (strf.len(elogvec.label) && strf.len(plogvec.label)) {

		sscanf(elogvec.label, "%lf", &esim)
		sscanf(plogvec.label, "%lf", &psim)

		if (esim > -1 && psim > -1) {

			for m = 0, genvec.size-1 {

				$o1.x[genvec.x[m]][1] = spacemat.x[mutmat.x[psim][m]][m]
				$o1.x[genvec.x[m]][2] = spacemat.x[mutmat.x[psim][m]+1][m]
			}

			tempnum = setnp(0)

			for p = 0, $o1.nrow-1 {

				// Na_so
				if (p == 0+tempnum) {

					// if Na_so < Na_ais, < Na_nod
					if (RunFitParm[p].val < RunFitParm[3+tempnum].val && RunFitParm[p].val < RunFitParm[5+tempnum].val) {

						$o1.x[p][0] = 0
						$o1.x[1+tempnum][0] = 0
						$o1.x[2+tempnum][0] = 0
					}
				}

				// Na_ais
				if (p == 3+tempnum) {
					
					if (!$o1.x[0+tempnum][0]) {

						// if Na_ais > Na_int, > Na_col
						if (RunFitParm[p].val > RunFitParm[4+tempnum].val && RunFitParm[p].val > RunFitParm[7+tempnum].val) {

							$o1.x[p][0] = 0
						}
					}
				}

				// Na_int
				if (p == 4+tempnum) {

					if (!$o1.x[3+tempnum][0]) {

						// if Na_int < Na_nod
						if (RunFitParm[p].val < RunFitParm[5+tempnum].val) {

							$o1.x[p][0] = 0	
						}
					}
				}

				// Na_nod
				if (p == 5+tempnum) {

					if (!$o1.x[4+tempnum][0]) {

						// if Na_nod > Na_col
						if (RunFitParm[p].val > RunFitParm[7+tempnum].val) {

							$o1.x[p][0] = 0
							$o1.x[7+tempnum][0] = 0
						}
					}

					// no restrictive statements can definitively be made about Na_end
					$o1.x[6+tempnum][0] = 0	
				}

				// Nap_ais
				if (p == 8+tempnum) {

					// Nap_ais > Nap_int
					if (RunFitParm[p].val > RunFitParm[9+tempnum].val) {

						$o1.x[p][0] = 0
					}
				}

				// Nap_int
				if (p == 9+tempnum) {

					// Nap_int < Nap_ais, < Nap_nod
					if (RunFitParm[p].val < RunFitParm[8+tempnum].val && RunFitParm[p].val < RunFitParm[10+tempnum].val) {

						$o1.x[p][0] = 0
						// Nap_nod
						$o1.x[10+tempnum][0] = 0
					}

					// No definitive restrictions on Nap_end
					$o1.x[11+tempnum][0] = 0
				}

				// Kv1_so
				if (p == 12+tempnum) {

					// Kv1_so < Kv1_ais, < Kv1_juxta, if present
					if (RunFitParm[p].val < RunFitParm[15+tempnum].val) {

						if (juxtaparanod) {

							if (RunFitParm[p].val < RunFitParm[35+tempnum].val) {

								$o1.x[p][0] = 0
								// lc_Kv_Kv1_de
								$o1.x[13+tempnum][0] = 0
								// Kv1_prox
								$o1.x[14+tempnum][0] = 0
							}
						
						} else {

							$o1.x[p][0] = 0
							// lc_Kv_Kv1_de
							$o1.x[13+tempnum][0] = 0
							// Kv1_prox
							$o1.x[14+tempnum][0] = 0
						}
					}
				}

				// Kv1_ais
				if (p == 15+tempnum) {

					if (!$o1.x[12+tempnum][0]) {

						// if Kv1_ais > Kv1_int, > Kv1_nod, > Kv1_col
						if (RunFitParm[p].val > RunFitParm[16+tempnum].val && RunFitParm[p].val > RunFitParm[17+tempnum].val && RunFitParm[p].val > RunFitParm[19+tempnum].val) {

							$o1.x[p][0] = 0
						}
					}
				}

				// Kv1_int
				if (p == 16+tempnum) {

					// Kv1_int < Kv1_ais
					if (!$o1.x[15+tempnum][0]) {

						if (juxtaparanod) {

							if (RunFitParm[p].val < RunFitParm[35+tempnum].val) {

								$o1.x[p][0] = 0
							}
						
						} else {

							$o1.x[p][0] = 0
						}
					}
				}

				// Kv1_nod
				if (p == 17+tempnum) {

					// Kv1_nod < Kv1_ais
					if (!$o1.x[15+tempnum][0]) {

						if (juxtaparanod) {

							if (RunFitParm[p].val < RunFitParm[35+tempnum].val) {

								$o1.x[p][0] = 0
							}
						
						} else {

							$o1.x[p][0] = 0
						}
					}

					// No restrictive statements can be made about Kv1_end
					$o1.x[18+tempnum][0] = 0
				}

				// Kv1_col
				if (p == 19+tempnum) {

					// if Kv1_col < Kv1_ais
					if (!$o1.x[15+tempnum][0]) {

						if (juxtaparanod) {

							if (RunFitParm[p].val < RunFitParm[35+tempnum].val) {

								$o1.x[p][0] = 0
							}
						
						} else {

							$o1.x[p][0] = 0
						}
					}
				}

				// Kv_so
				if (p == 20+tempnum) {

					if (!$o1.x[13+tempnum][0]) {

						$o1.x[p][0] = 0
					}
				}

				// Kv7_so
				if (p == 21+tempnum) {

					// if Kv7_so >= Kv7_de, < Kv7_ais, < Kv7_nod
					if (RunFitParm[p].val >= RunFitParm[22+tempnum].val && RunFitParm[p].val < RunFitParm[24+tempnum].val && RunFitParm[p].val < RunFitParm[26+tempnum].val) {

						$o1.x[p][0] = 0
						// Kv7_de
						$o1.x[22+tempnum][0] = 0
						// Kv7_prox
						$o1.x[23+tempnum][0] = 0
					}
				}

				// Kv7_ais
				if (p == 24+tempnum) {

					if (!$o1.x[21+tempnum][0]) {

						// if Kv7_ais > Kv7_int, > Kv7_col
						if (RunFitParm[p].val > RunFitParm[25+tempnum].val && RunFitParm[p].val > RunFitParm[28+tempnum].val) {

							$o1.x[p][0] = 0
						}
					}
				}

				// Kv7_int
				if (p == 25+tempnum) {

					if (!$o1.x[24+tempnum][0]) {

						// if Kv7_int < Kv7_nod && Kv7_int < Kv7_col
						if (RunFitParm[p].val < RunFitParm[26+tempnum].val) {						

							$o1.x[p][0] = 0
						}
					}
				}

				// Kv7_nod
				if (p == 26+tempnum) {

					if (!$o1.x[25+tempnum][0]) {

						// if Kv7_nod > Kv7_col
						if (RunFitParm[p].val > RunFitParm[28+tempnum].val) {

								$o1.x[p][0] = 0
								// Kv7_col
								$o1.x[28+tempnum][0] = 0
						}
					}

					// no definitive restrictions on Kv7_end
					$o1.x[27+tempnum][0] = 0
				}

				// No restrictive statements can be made at this time on KCa, Ca, It2, H_so, tc_H_de, H_ax
				if (p == 29+tempnum) {

					$o1.x[p][0] = 0
					$o1.x[30+tempnum][0] = 0
					$o1.x[31+tempnum][0] = 0
					$o1.x[32+tempnum][0] = 0
					$o1.x[33+tempnum][0] = 0
					$o1.x[34+tempnum][0] = 0
				}

				// Kv1_juxta
				if (p == 35+tempnum) {

					// if Kv1_juxta > Kv1_so, > Kv1_int, > Kv1_nod, > Kv1_col
					if (!$o1.x[12+tempnum][0] && !$o1.x[16+tempnum][0] && !$o1.x[17+tempnum][0] && !$o1.x[19+tempnum][0]) {

						$o1.x[35+tempnum][0] = 0
					}
				}
			}			
		}
	}

	return $o1
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc mutparam() {local p localobj prand, tempvec

	prand = new Random()
	tempvec = new Vector()

	for p = 0, $o1.nrow-1 {

		tempvec.resize(tempvec.size+1)

		if ($o1.x[p][0]) {
			
			tempvec.x[tempvec.size-1] = prand.uniform($o1.x[p][1], $o1.x[p][2])
		
		} else {

			tempvec.x[tempvec.size-1] = RunFitParm[p].val
		}
	}

	return tempvec
}
// --------------------------------------------------------------------------------


// --------------------------------------------------------------------------------
proc optimizewrap() {local tempnum, iiamp localobj rangemat

	initfit()
	savepelog()

	tempnum = iampvec.indwhere("==", stim.amp)

	if (tempnum != -1) {

		iiamp = tempnum
	
	} else {

		iiamp = 0
	}

	crdir(root, "out", 0)
	getmod()
	crdir(out, modstr)
	// create iampdir

	getmat(ses, vdatfilestr, vdatmat)
	tdatvec = new Vector()
	tdatvec.append(vdatmat.getcol(0))
	nsigt = getnsig(tdatvec)
	dt = setnsig(dt, nsigt)
	nsigv = getnsig(vdatmat.getcol(1))
	
	setmaxform()
	setmaxformvec()
	setvform()
	setvformvec()
	settform()
	settformvec()

	croutmat(1)
	croutlist(1)

	getpheader()
	geteheader()
	getvheader(1)

	adj_injbound(mode_)

	getpnorm()

	tol = settol(iiamp)
	maxstepsize = setmaxstepsize(tol)

	eqlist.o(0).resize(0)
	pqlist.o(0).resize(0)

	saveopt(iampdir, 1)

	print "\nRunning simulation 1 of 1"

	// required optimize parameters:
	// $1 = iiamp
	// $2 = mode_
	// $3 = ll
	// $4 = uopt
	// $o5 = pnormvec
	// $6 = tol
	// $7 = maxstepsize
	// $o8 = eqvec from eqlist, to be updated with resultant quad errors
	// $o9 = pqvec from pqlist, to be updated with resultant quad parameters
	// $o10 = elogvec from eloglist, to be updated
	// $o11 = plogvec from ploglist, to be updated
	// $12 = sim
	// $13 = scount
	// $14 = istart
	// $15 = internal job id, for GUI-based calls to optimize (718573=GUI)
	optimize(iiamp, mode_, ll, uopt, pnormvec, tol, maxstepsize, eqlist.o(0), pqlist.o(0), 0, 0, 0, 718573)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc setoptpanel() {

	optibox = new VBox(3)
	optibox.intercept(1)
	xpanel("", 1)
	xbutton("optimize", "optimizewrap()")
	xlabel(" spatially non-uniform parameter distributions")
	xpanel()
	xpanel("", 1)
	xpvalue("nquad", &nquad_, 0, "", 0, 1)
	xlabel(" ")
	xpvalue("nefun", &nefun_, 0, "", 0, 1)
	xpanel()
	optibox.intercept(0)
	optibox.map("Non-uniform (NU) optimization", 998, 961, 360.96, 93.12)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// change fit data according to iiamp and imported vdat
// $1 = iiamp
// $2 = mode_
proc changedata() {local f localobj boundvec, weightvec, tempxvec

	for f = 0, nf-1 {

		// store already set bounds, if different from default
		if (RegionFitness[f].boundary.x[0] != RegionFitness[f].xdat.x[0] || RegionFitness[f].boundary.x[RegionFitness[f].boundary.size-1] != RegionFitness[f].xdat.x[RegionFitness[f].xdat.size-1] || RegionFitness[f].boundary.size > 2) {

			// store those bounds in boundvec
			boundvec = new Vector()
			boundvec.append(RegionFitness[f].boundary)
			// also store the associated weights in weightvec
			weightvec = new Vector()
			weightvec.append(RegionFitness[f].weight)

			// set data to new iamp
			RegionFitness[f].set_data(vdatmat.getcol(0), vdatmat.getcol($1*nf+f+1))

			// restore previous boudaries and weights (the associated dw get taken care of)
			RegionFitness[f].boundary = new Vector()
			RegionFitness[f].boundary.append(boundvec)
			RegionFitness[f].weight = new Vector()
			RegionFitness[f].weight.append(weightvec)

			// to finalize the restoration in the GUI, need...
			tempxvec = new Vector()
			tempxvec.append(RegionFitness[f].xdat)
			RegionFitness[f].set_modelx(tempxvec)
		
		} else {

			// if already set bounds same as default, simply change data for new iamp
			RegionFitness[f].set_data(vdatmat.getcol(0), vdatmat.getcol($1*nf+f+1))
		}
	}

	strdef chgdata_iampstr
	getiamp($1, chgdata_iampstr)
	print "Fit data changed to ", chgdata_iampstr, " voltage response"	
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// $1 = iiamp
// $2 = 0, or 1; whether to rewrite and reload associated data files and windows

proc reseticlamp() {local wstart, wkill, win, interval, wcount
	
	{stim.amp = iampvec.x[$1]}
	printclamp()
	changedata($1)
	
	if ($2 == 1) {

		writenum(ses, iampfilestr, iampvec.x[$1])
		writefitdata($1)

		writevtplot(iampvec.x[$1])
		writevxplot(iampvec.x[$1])
		writeshape(iampvec.x[$1])

		loadfile(1, ses, vtplotfilestr)
		loadfile(1, ses, vxplotfilestr)
		loadfile(1, ses, shapeplotfilestr)
	}
	
	// deprecated: as window replacement is slow and does not seem to work for every window type.
	// windows are therefore replaced directly on top of each other.
	// window replacement is best for GUI-based model exploration. Otherwise, 
	// substantial slowdown occurs with every cycle of window replacement.
	// if (!para) {
		
	// 	wstart = 3
	// 	wkill = 2+nf
	// 	win = wstart + getvar(ses, "resetbit.dat") * (PWM.count - wstart - wkill)
	// 	sprint(wstr, "%s%d%s", "PWM.close(", win, ")")
	// 	timer = new Timer(wstr)
	// 	interval = 0.2
	// 	timer.seconds(interval)
	// 	PWM.close(win)
	// 	wcount = win
		
	// 	while (wcount <= win+nf+1) {
	// 		timer.start()
	// 		wcount += 1
	// 	}
	// 	timer.end()

	// 	while (wcount <= win+nf+2) {
		
	// 		if (wcount > win+nf+1) {	

	// 			writevtplot(mode_, stim.amp)
	// 			writevxplot(mode_, stim.amp)
	// 			writeshape(mode_, stim.amp)

	// 			if (mode_ == 0) {
					
	// 				loadfile(1, ses, "vtplot-pas.ses")
	// 				loadfile(1, ses, "vxplot-pas.ses")
	// 				loadfile(1, ses, "shapeplot-pas.ses")

	// 			} else if (mode_ == 1) {

	// 				loadfile(1, ses, "vtplot-act.ses")
	// 				loadfile(1, ses, "vxplot-act.ses")
	// 				loadfile(1, ses, "shapeplot-act.ses")					
	// 			}

	// 			writebit(ses, "resetbit.dat", 1)

	// 			wcount = win+nf+3
	// 		}
	// 	}
		
	// 	wstr = ""
	// }
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getoptsoln() {local k localobj tempmat

	if (getiampdir()) {

		if (chkdir(iampdir, "\npmatr.dat\n") || chkdir(iampdir, "\npmatr-all.dat\n")) {

			if (numarg() == 2 && argtype(2) == 2) {

				if (!strcmp($s2, "all")) {

					getmat(iampdir, "pmatr-all.dat", tempmat)
				
				} else {

					getmat(iampdir, "pmatr.dat", tempmat)
				}
			}		

			solnvec = new Vector(tempmat.getrow(0).size)

			for k = 0, solnvec.size-1 {

				solnvec.x[k] = tempmat.getrow(0).x[k]
			}

			updfitparam(solnvec)
			getpnorm()

			print "Optimal parameters loaded for ", modstr

			return solnvec.size
		
		} else {

			print "Optimal parameters do not exist for ", modstr

			getoptpas($1)

			return 0
		}
	
	} else {

		print "Optimization directory does not exist for ", modstr

		getoptpas($1)

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getoptpas() {local k, tempnum

	tempnum = $1
	mode_ = 0	
	
	if (getmod()) {

		if (chkdir(moddir, "pematr.dat")) {

			getmat(moddir, "pematr.dat", tempmat)

			solnvec = new Vector(setnp(mode_))

			for k = 0, setnp(mode_)-1 solnvec.x[k] = tempmat.getrow(tempmat.nrow-2).x[k]

			updfitparam(solnvec)
			getpnorm()

			print "Optimal parameters loaded for ", modstr

			mode_ = $1			

			return solnvec.size
	
		} else {

			print "Optimal parameters do not exist for ", modstr

			mode_ = $1

			return 0
		}
	
	} else {

		print "Parameter directory does not exist for ", modstr

		mode_ = $1

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc perr() {local f

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "No arguments required. Will print each fit error sequentially."
			stop
		}
	}

	sprint(tempstr, "%s", "")

	for f = 0, nf-1 {

		sprint(numstr, vformvec, RegionFitness[f].ydat_.meansqerr(FitnessGenerator[0].yveclist.o(f), RegionFitness[f].dw_))
		sprint(tempstr, "%s%s", tempstr, numstr)
	}

	print tempstr

	sprint(tempstr, "%s", "")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc ppnorm() {local k, tempnum

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "No arguments required. Will print each pnorm."
			stop
		}
	}

	tempnum = setnp(0)

	for k = tempnum, pnormvec.size-1 {

		print pnormvec.x[k]
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getsecparam() {local seg, countseg, pos, nrecrows, k localobj tempvec, tempmat

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) section name (string) or sectionlist (object)"
			print "2) variable of interest to record (\"v\" or \"vext\", as string)"
			print "3) optional file name header (especially for sectionlist names, as string)"
			stop
		}
	}

	countseg = 0

	if (argtype(1) == 2) {

		forsec $s1 {

			countseg = nseg 
		}
	
	} else {

		forsec $o1 {

			countseg += nseg
		}
	}

	nrecrows = tstop/dt
	
	tempvec = new Vector(1, nrecrows)
	
	tempvec.floor
	nrecrows = tempvec.x[0]+1
	
	crveclist(countseg+1, templist)
	
	for k = 0, templist.count-1 {

		templist.o(k).resize(nrecrows)
	}

	strdef exprtok_left, exprtok_right
	
	if (!strcmp($s2, "v")) {

		sprint(exprtok_left, ".v(")
	}
	
	if (!strcmp($s2, "vext")) {

		sprint(exprtok_left, ".vext(")
	}
	
	sprint(exprtok_right, ")")	
	
	templist.o(0).record(&t)
	num = 1
	strdef getsecparamstr
	
	if (argtype(1) == 2) {

		forsec $s1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(getsecparamstr, "%s%g%s%s%s%g%s%s", "~templist.o(", num, ").record(&", $s1, exprtok_left, pos, exprtok_right, exprtok_right)
			execute(getsecparamstr)
			num += 1
		}

	} else {

		forsec $o1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(getsecparamstr, "%s%g%s%s%s%g%s%s", "~templist.o(", num, ").record(&", secname(), exprtok_left, pos, exprtok_right, exprtok_right)
			execute(getsecparamstr)
			num += 1
		}
	}

	init()
	run()
	
	getmod()
	
	if (numarg() == 3 && argtype(3) == 2) {

		if (argtype(1) == 2) {

			sprint(tempstr, "%s%s%s%s%s%s%s%s", $s3, "_", $s1, "_", $s2, "_", modstr, ".dat")
		
		} else {

			sprint(tempstr, "%s%s%s%s%s%s", $s3, "_", $s2, "_", modstr, ".dat")	
		}

	} else {

		if (argtype(1) == 2) {

			sprint(tempstr, "%s%s%s%s%s%s", $s1, "_", $s2, "_", modstr, ".dat")
		
		} else {

			sprint(tempstr, "%s%s%s%s", $s2, "_", modstr, ".dat")	
		}				
	}
	
	tempmat = new Matrix(nrecrows, countseg+1)
	
	for k = 0, templist.count-1 {

		tempmat.setcol(k, templist.o(k))
	}
	
	savemat(ses, tempstr, tempmat, vformvec)

	objref templist
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc gadd() {local seg, pos

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Add v(t) plot"
			print "Enter:"
			print "1) section (string) or sectionlist (object) to plot"
			print "2) variable of interest to plot (string), e.g. \"v\" or \"vext\""
			stop
		}
	}

	strdef exprtok_left, exprtok_right
	
	if (!strcmp($s2, "v")) {

		sprint(exprtok_left, ".v(")
	}
	
	if (!strcmp($s2, "vext")) {

		sprint(exprtok_left, ".vext(")
	}
	
	sprint(exprtok_right, ")")
	
	if (!newg) {

		graphobj = new Graph(0)
		graphobj.size(-1e-7, tstop, -80, 40)
		graphobj.view(-1e-7, -80, tstop, 120, 612, 726, 678.72, 277.12)		
		newg = 1
	
	} else {

		graphobj.erase_all()
	}

	if (argtype(1) == 2) {
	
		forsec $s2 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(varstr, "%s%s%g%s", $s2, exprtok_left, pos, exprtok_right)
			graphobj.addexpr(varstr)
		}

	} else {

		forsec $o1 for seg = 1, nseg {

			pos = (2*seg-1)/(2*nseg)
			sprint(varstr, "%s%s%g%s", secname(), exprtok_left, pos, exprtok_right)
			graphobj.addexpr(varstr)
		}
	}

	graphList[0].append(graphobj)
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
proc chlam() {local k localobj tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) expected number of lamellae, e.g. 16"
			print "2) base multiple for changing this, e.g. 2 or 10"
			print "3) start power range (>= 0), ex: 0"
			print "4) end power range, ex: 6"
			print "5) desired sectionlist (object) or section name (string) to record"
			print "6) variable of interest (string). Ex: \"v\" or \"vext\""
			print "7) optional filename header (string)"
			stop
		}
	}

	tempvec = new Vector(3, 0)

	tempvec.x[0] = Cmy_norm * $1 * 2
	tempvec.x[1] = Rmy_norm/($1 * 2)
	tempvec.x[2] = (smy-1)/($1 * 2)

	for k = 0, $4-$3 {

		Cmy_norm = tempvec.x[0]/(($2^($3+k))*2)
		Rmy_norm = tempvec.x[1] * (($2^($3+k))*2)
		smy = 1 + tempvec.x[2] * (($2^($3+k))*2)

		getpnorm()
		updfitparam(pnormvec)
		init()

		strdef lamstr
		
		sprint(lamstr, "%s%g", "lamellae = ", $2^($3+k))
		
		if (numarg() == 7) {

			sprint(lamstr, "%s%s%s", $s7, ", ", lamstr)

		} else {

			sprint(lamstr, "%s%s", "_", lamstr)			
		}
		
		if (argtype(5) == 2) {

			getsecparam($s5, $s6, lamstr)
	
		} else {

			getsecparam($o5, $s6, lamstr)
		}
	}

	Cmy_norm = tempvec.x[0]/($1 * 2)
	Rmy_norm = tempvec.x[1] * ($1 * 2)
	smy = (tempvec.x[2] * $1 * 2) + 1

	getpnorm()
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta1() {local mpa, mpn, apa, apn, k, delta_pa, delta_pn

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) desired delta_pa (nm)"
			print "2) desired delta_pn (nm)"
			stop
		}
	}

	delta_pa = 12.3
	delta_pn = 7.4

	if (!chgdelta1) {

		dpa = getdiam(interparanodal)
		apa = PI*delta_pa*(1e-7)*(dpa*(1e-4)+delta_pa*(1e-7))
		Rpa = rpa_norm * rpa_low * (1e6) * apa

		dpn = getdiam(paranodal)
		apn = PI*delta_pn*(1e-7)*(dpn*(1e-4)+delta_pn*(1e-7))
		Rpn = rpa_norm * parafact_norm * rpa_low * (1e6) * apn

		rpa_norm_orig = rpa_norm

		chgdelta1 = 1
	}
	
	mpa = $1/delta_pa
	apa = PI*delta_pa*(1e-7)*mpa*(dpa*(1e-4)+delta_pa*(1e-7)*mpa)
	rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
	
	mpn = $2/delta_pn
	apn = PI*delta_pn*(1e-7)*mpn*(dpn*(1e-4)+delta_pn*(1e-7)*mpn)	
	parafact_norm = (((Rpn/apn)*(1e-6))/rpa_low)/rpa_norm_orig

	getpnorm()
	updfitparam(pnormvec)

	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta() {local delta_pa, delta_pn, k

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) desired submyelin space to change the radius of (string), e.g. \"pa\", \"pn\", or \"papn\""
			print "2) base multiple to effect this change, ex: 2, 10, etc"
			print "3) the power range start, ex: -2"
			print "4) the power range end, ex: 3"
			print "5) the desired sectionlist (object) or section name (string) to record"
			print "6) the variable of interest (string), e.g. \"v\" or \"vext\""
			print "7) a file name header (string)"
			stop
		}
	}

	delta_pa = 12.3
	delta_pn = 7.4
	strdef chdelta_header

	for k = 0, $4-$3 {

		if (!strcmp($s1, "pa")) {
			
			chdelta1(($2^($3+k))*delta_pa, delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pa, " nm")
		}

		if (!strcmp($s1, "pn")) {
			
			chdelta1(delta_pn, ($2^($3+k))*delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pn, " nm")
		}

		if (!strcmp($s1, "papn")) {
			
			chdelta1(($2^($3+k))*delta_pa, ($2^($3+k))*delta_pn)
			sprint(chdelta_header, "%s%s%s%s%g%s%g%s", $s7, ", chdelta_", $s1, " ", ($2^($3+k))*delta_pa, " nm and ", ($2^($3+k))*delta_pn, " nm")
		}		

		if (argtype(5) == 2) {
		
			getsecparam($s5, $s6, chdelta_header)

		} else {

			getsecparam($o5, $s6, chdelta_header)
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta_pa() {local dpa, dpn, apa, apn, Rpa, Rpn, k, rpa_norm_orig, parafact_norm_orig, Rmy_norm_orig

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) base multiple for changing delta, e.g. 2 or 10"
			print "2 & 3) the power range, e.g. -2, 2"
			print "4) the desired sectionlist to record"
			print "5) the variable of interest. Ex: v or vext"
			print "6) an optional filename header"
			stop
		}
	}

	dpa = getdiam(interparanodal)
	dpn = getdiam(paranodal)
	
	apa = PI*12.3*(1e-7)*(dpa*(1e-4)+12.3*(1e-7))
	apn = PI*7.4*(1e-7)*(dpn*(1e-4)+7.4*(1e-7))
	
	Rpa = rpa_norm * rpa_low * (1e6) * apa
	Rpn = rpa_norm * parafact_norm * rpa_low * (1e6) * apn
	
	Rmy = Rmy_norm * Rmy_low

	rpa_norm_orig = rpa_norm
	parafact_norm_orig = parafact_norm
	Rmy_norm_orig = Rmy_norm

	for k = 0, $3-$2 {

		apa = PI*12.3*(1e-7)*($1^($2+k))*(dpa*(1e-4)+12.3*(1e-7)*($1^($2+k)))
		apn = PI*7.4*(1e-7)*($1^($2+k))*(dpn*(1e-4)+7.4*(1e-7)*($1^($2+k)))

		rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
		parafact_norm = (((Rpn/apn)*(1e-6))/rpa_low)/rpa_norm

		Rmy_norm = (Rmy/((0.5*(dpa+dpn))/((0.5*(dpa+dpn)) + 2*(0.5*(dpa+dpn)*$1^($2+k)))))/Rmy_low

		getpnorm()
		updfitparam(pnormvec)

		sprint(varstr, "%s%g", "new delta *= ", ($1^($2+k)))

		if (numarg() == 6 && argtype(6) == 2) {

			sprint(varstr, "%s%s%s", $s6, ", ", varstr)
		}
		
		getsecparam($s5, $o4, varstr)
	}

	rpa_norm = rpa_norm_orig
	parafact_norm = parafact_norm_orig
	Rmy_norm = Rmy_norm_orig
	
	getpnorm()
	updfitparam(pnormvec)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdelta_pa() {local ad, apa, Rpa, k, rpa_norm_orig, Rmy_norm_orig

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) an expected delta (nm), e.g. 12.3 Current rpa corresponds to base delta_pa."
			print "2) a base multiple for changing delta, e.g. 2 or 10"
			print "3 & 4) the power range, e.g. -2, 2"
			print "5) the desired sectionlist to record"
			print "6) the variable of interest. Ex: v or vext"
			print "7) an optional filename header"
			stop
		}
	}

	ad = getdiam(internodal)
	apa = PI*12*(1e-7)*(ad*(1e-4)+12*(1e-7))
	Rpa = rpa_norm * rpa_low * (1e6) * apa
	Rmy = Rmy_norm * Rmy_low

	rpa_norm_orig = rpa_norm
	Rmy_norm_orig = Rmy_norm

	for k = 0, $4-$3 {

		apa = PI*12*(1e-7)*(1/12)*(ad*(1e-4)+12*(1e-7)*(1/12))
		rpa_norm = ((Rpa/apa)*(1e-6))/rpa_low
		Rmy_norm = (Rmy/(ad/(ad + 2*(12*(1/12)))))/Rmy_low

		getpnorm()
		updfitparam(pnormvec)
		init()

		sprint(varstr, "%s%g%s%g%s", "base delta_pa = ", $1, "nm, new delta_pa = ", $1*($2^($3+k)), "nm")

		if (numarg() == 7 && argtype(7) == 2) {

			sprint(varstr, "%s%s%s", $s7, ", ", varstr)
		}
		
		getsecparam($s6, $o5, varstr)
	}

	rpa_norm = rpa_norm_orig
	Rmy_norm = Rmy_norm_orig
	
	getpnorm()
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chparam() {local k localobj tempvec, paramvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) the parameter of interest (string), e.g. \"Ri\""
			print "2) the base multiple for fold changes, e.g. 2 or 10"
			print "3) the start range of the number of fold changes, e.g. -5"
			print "4) the end range of the number of fold changes, e.g. 5"
			print "5) the desired section name (string) or sectionlist (object) to record, e.g. \"axon[10]\" or axonal"
			print "6) the desired variable to record (string), e.g. \"v\" or \"vext\""
			print "7) an optional file header"

			print "\nHere is the list of available parameters:"
			for k = 0, pnamelist.count-1 print pnamelist.o(k).label
			stop
		}
	}

	tempvec = new Vector(2, 0)

	for k = 0, pnamelist.count-1 {

		if (!strcmp($s1, pnamelist.o(k).label)) {

			tempvec.x[0] = k
			k = pnamelist.count-1
		}
	}
	tempvec.x[1] = pnormvec.x[tempvec.x[0]]

	paramvec = new Vector($4-$3+1, 0)

	for k = 0, $4-$3 {

		paramvec.x[k] = tempvec.x[1] * $2^($3+k)

		pnormvec.x[tempvec.x[0]] = paramvec.x[k]
		updfitparam(pnormvec)
		init()

		strdef header
		
		sprint(header, "%s%s%g%s%s", $s1, "=", ($2^($3+k)), "*", $s1)

		if (numarg() == 7 && argtype(7) == 2) {

			sprint(header, "%s%s%s", $s7, ", ", header)
		}

		if (argtype(5) == 1) {
			
			getsecparam($s6, $o5, header)
		
		} else if (argtype(5) == 2) {

			getsecparam($s6, $s5, header)
		
		} else {

			print "Error: enter the desired section name (string) or sectionlist (object) to record, e.g. \"axon[10]\" or axonal"
			stop
		}
	}

	savepelog()

	pnormvec.x[tempvec.x[0]] = tempvec.x[1]
	updfitparam(pnormvec)
	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getthresh() {local dx localobj tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) time vector"
			print "2) voltage vector"
			print "3) desired dV/dt threshold (V/s)"
			print "Returns threshold onset (time vector units)"
			stop
		}
	}

	dx = ($o1.x[$o1.size-1]-$o1.x[0])/($o1.size-1)

	tempvec = new Vector()

	tempvec.deriv($o2, dx, 1)

	return $o1.x[tempvec.indwhere(">=", $3)]
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chdiam() {local k, m localobj diamvec, tempvec, drand

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) sectionlist"
			print "2) diameter slice to add or remove from each measurement in given sectionlist in um (e.g. 0.3 um)"
			stop
		}
	}

	diamvec = new Vector()
	forsec $o1 for (x, 0) diamvec.append(diam(x))

	drand = new Random()
	drand.normal(0, 1)

	tempvec = new Vector()
	for k = 0, diamvec.size-1 tempvec.append(diamvec.x[k] + drand.repick()*$2)

	m = -1
	forsec $o1 for (x, 0) {

		m += 1
		diam(x) = tempvec.x[m]
	}

	print "DIAMETER CHANGE ACTIVATED"
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc randomizep() {local k localobj prand, tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Randomize parameter range (0, np-1) within parameter bound (plow, phi)"
			print "Enter:"
			print "1) start range, i.e. 0 or 8"
			print "2) end range, i.e. getnp()-1"
			print "3) optional: randomization seed (0-n). Default = 0."
			stop
		}
	}

	if (numarg() == 3) {
		
		prand = new Random($3)
	
	} else {
	
		prand = new Random()
	}
	
	tempvec = new Vector()

	getplow()
	getphi()

	for k = $1, $2 {

		prand.uniform(1, phivec.x[k]/plowvec.x[k])
		tempvec.append(prand.repick())
	}

	updfitparam(tempvec, $1, $2)

	init()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// based on the 3 sigma approach
proc getthresh() {local f, deli, k localobj tempyvec, tempvec

	speedvec = new Vector()

	for f = 0, nf-1 {

		tempyvec = new Vector()

		deli = RegionFitness[f].xdat.indwhere(">=", stim.del)

		for k = 0, deli tempyvec.append(RegionFitness[f].ydat.x[k])

		tempvec = new Vector()

		tempvec.deriv(tempyvec, dt, 1)

		speedvec.append(4*tempvec.stdev())
	}
}
// --------------------------------------------------------------------------------
