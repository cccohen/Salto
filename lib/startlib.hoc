// Salto
// (c) Charles CH Cohen, 2014-present
// this software is released to the public under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 
// International license (CC BY-NC-ND 4.0, in English).
// for any questions, please email c.cohen@gmx.com



// -------------------------------Variables----------------------------------------
objref getfile, writefile, llc, strf, PWM, timer
objref tempobj, tempmat, templist, tempseclist, tempvec, testvec, tempxvec, tempyvec, rvec
objref recloclist, recseclist, loclist, subloclist, sublocvec, iampvec, piplist, fitvarlist, pnamelist, vvarlist, dirlist
objref secref, tsecref, cdiamvec, pvec, pnormvec
objref BBvec, celltypevec, injvec, vdatmat, newvdatmat, vdatlist, vdatvec, tdatvec, tcmpvec, vpathlist
objref xcvec, ycvec, avgxcvec, avgycvec
objref noisevec, pdefvec, pnormdefvec, plowvec, phivec, doargvec, uselogvec

getfile = new File()
writefile = new File()
llc = new ParallelContext()
strf = new StringFunctions()
PWM = new PWManager()

strdef cwd, tempstr, teststr, tempdir, testdir, tempheader, commstr, rstr, ostr, wstr, filestr, qstr, astr
strdef maxform, maxnum, maxformvec
strdef tform, tformvec, vform, vformvec
strdef trailzero, format, numstr, numhead, powstr, headstr, tailstr
strdef locstr, sublocstr, reclocstr, BBqstr, BBqstr_left, BBqstr_right
strdef decpipseclist, crpipseclist, crcurpip, crfirstsec, crstarttip, crremtip, piplistappend
strdef tokpip, strpipc, secstr, parstr, gparstr, gchstr, stimstr, durstr, delstr, wstr
strdef upiampqstr, iampqstr, niampqstr, iampqstr_first, iampqstr_next, importqstr, axontypestr
strdef modestr, recloclistfilestr, temprecfilestr, iampvecfilestr, locstimfilestr, injvecfilestr, iampfilestr, idelfilestr, idurfilestr, vdatfilestr
strdef runcontrolfilestr, vtplotfilestr, vxplotfilestr, shapeplotfilestr, savedatafilestr, savedatadatafilestr, savedataparamfilestr, doargfilestr
strdef na_gatingfilestr, miscparamfilestr
strdef SOstr, AXstr, DEstr, APstr
strdef modeltypestr, modstrtype, modstr, moddir, iampstr, iampdir, manstr, mandir

idata = 0
nrec = 0
piploc = 1
stack = 0
nstack = 500
countsecflag = 1
num = 0
pow = 0
ll = 0
chgdelta1 = 0
min_weight = 10
runtime = 0
maxtime = 1e9
overtime = 0
hourlog = 1
chkhour = 2

NOMY = 0
SC = 0
DC = 0
DCPARA = 0
axontypestr = "UNKNOWN"
demy = 0
// --------------------------------------------------------------------------------



// --------------------------------chkcwd------------------------------------------
// takes (1) cwd
// returns 1 if cwd empty, else 0.
// to be used if calling functions changes cwd.
func chkcwd() {

	if (strf.len($s1) == 0) {

		return 1

	} else {

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chkin() {local chk

	chk = chkcwd(cwd)

	if (chk) {

		cwd = getcwd()
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc chkout() {

	chdir(cwd)
	sprint(cwd, "%s", "")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc loadfile() {	

	if (numarg() == 2) {

		chkin()
		chdir($s1)
		
		load_file($s2)

		chkout()
	
	} else if (numarg() == 3) {

		chkin()
		chdir($s2)
		
		load_file($1, $s3)

		chkout()
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc run() {

	if (runtime >= maxtime) {

		running_ = 0
		stoprun = 1

		overtime = 1		
	
	} else {

		running_ = 1
		stdinit()
		continuerun(tstop)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc stdinit() {

	cvode_simgraph()

	runtime += realtime
	
	realtime = 0
	setdt()
	init()
	initPlot()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) dir, (2) filename
// outputs first number in filename. Best for massively parallel file access.

func getvar() {local var

	chkin()
	chdir($s1)
	
	getfile.ropen($s2)

	var = getfile.scanvar()
	
	getfile.close()

	chkout()

	return var	
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc getvec() {local var, nvar

	chkin()
	chdir($s1)
	
	getfile.ropen($s2)
	
	$o3 = new Vector()
	
	while (!getfile.eof) {

		$o3.resize($o3.size+1)
		$o3.x[$o3.size-1] = getfile.scanvar()
	}
	
	getfile.close()

	chkout()

	return $o3
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// interprets string number data, usually stored in a vector label, into vector data.
// to be used with getline, which returns such labels.
obfunc getvarvec() {

	sprint(rstr, $o1.label)
	$o1.resize(0)

	while (strf.len(rstr)) {

		if (sscanf(rstr, "%lf", &num) == 1) {

			$o1.resize($o1.size+1)
			$o1.x[$o1.size-1] = num

			if (strf.substr(rstr, "\t") >= 1) {

				strf.tail(rstr, "\t", rstr)
			}

			if (strf.substr(rstr, "\n") >= 1) {

				strf.tail(rstr, "\n", rstr)
			}
		}
	}

	return $o1	
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getnstr() {local nstr

	chkin()
	chdir($s1)

	nstr = 0

	getfile.ropen($s2)	
	while (!getfile.eof) {

		if (getfile.scanstr(rstr) > 0) {

			nstr += 1
		}
	}
	getfile.close()
	
	chkout()
	return nstr
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getstrlist() {local nstr, strn

	if (nstr = getnstr($s1, $s2)) {

		chkin()
		chdir($s1)

		$o3 = crveclist($o3, nstr)
		
		strn = 0
		getfile.ropen($s2)
		while (strn < nstr) {

			getfile.scanstr(rstr)
			$o3.o(strn).label(rstr)
			strn += 1
		}
		getfile.close()

		chkout()
		return $o3.count
	
	} else {

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getnline() {local nline

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) folder path"
			print "2) file name"
			print "Returns number of lines in file"
			stop
		}
	}

	chkin()
	chdir($s1)

	getfile.ropen($s2)
	nline = 0
	while (!getfile.eof) {

		// to read the first line as zeroth
		nline += 1
		// to advance lines. Reads up to and including the end of the line, 
		// which includes the newline (\n) character
		getfile.gets(tempstr)
	}
	getfile.close()
	sprint(tempstr, "%s", "")
	chkout()

	return nline
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc getline() {local nline, line, pos localobj tempvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) folder path"
			print "2) file name"
			print "3) line number"
			print "Returns a vector with the contents of the specified line number as a string in the vector's label"
			stop
		}
	}	

	nline = getnline($s1, $s2)

	chkin()
	chdir($s1)
	
	getfile.ropen($s2)

	line = 0
	while (line <= nline && $3 <= nline) {

		if (line == $3) {

			pos = getfile.tell
			line = nline
		}

		getfile.gets(rstr)
		line += 1
	}
	getfile.close()
	strf.head(rstr, "\n", rstr)
	tempvec = new Vector(1)
	tempvec.label(rstr)
	tempvec.x[0] = pos

	chkout()

	return tempvec
}
// --------------------------------------------------------------------------------



// ---------------------------------getstring--------------------------------------
// takes (1) dir, (2) filename, (3) str
// outputs first delimited string in filename in str
proc getstring() {

	chkin()
	chdir($s1)

	getfile.ropen($s2)

	getfile.scanstr($s3)

	getfile.close()

	chkout()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) output dir, (2) filename, (3) str, (4) append (=1) or write new (0)
proc writestr() {
	
	chkin()
	chdir($s1)	

	if (numarg() == 3) {

		writefile.wopen($s2)
	}

	if (numarg() == 4) {

		if ($4) {

			writefile.aopen($s2)
		
		} else {

			writefile.wopen($s2)
		}
	}

	writefile.printf($s3)

 	writefile.close()

	chkout()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) matdir, (2) matfilename, (3) matobj, (4) format, (5) header (optional)
// saves matobj as matfilename in matdir with format format and optional header.

proc savemat() {

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) destination folder"
			print "2) matrix file name"
			print "3) matrix object"
			print "4) content format"
			print "5) matrix header (optional)"
			stop
		}
	}

	chkin()
	chdir($s1)

	writefile.wopen($s2)

	if (numarg() == 5 && argtype(5) == 2) {

		if (strf.len($s5)) {

			writefile.printf($s5)
		}
	}
	
	$o3.fprint(writefile, $s4)
	writefile.close()

	chkout()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) vecdir, (2) vecfilename, (3) vecobj, (4) format (optional)
// saves vecobj as vecfilename in vecdir with optional format format.

proc savevec() {

	chkin()
	chdir($s1)
	
	writefile.wopen($s2)
	
	if (numarg() == 4) {
	
		$o3.printf(writefile, $s4)
	
	} else {
	
		setmaxformvec()
		$o3.printf(writefile, maxformvec)
	}
	
	writefile.close()

	chkout()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc loaddll() {

	if (unix_mac_pc() == 4 || unix_mac_pc() == 2) {

		nrn_load_dll("x86_64/.libs/libnrnmech.0.so")

	} else if (unix_mac_pc() == 1) {

		nrn_load_dll("x86_64/.libs/libnrnmech.so.0")
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func chkpara() {
	
	if (llc.nhost == 1) {

		ll = 0
	
	} else {

		ll = 1
	}

	return ll
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// mode_, idata
proc setfilestr() {

	if ($1 == 0 && $2 == 1) {

		doargfilestr = "doarg-pas.dat"
		iampvecfilestr = "iampvec-pas.dat"
		iampfilestr = "iamp-pas.dat"		
		idelfilestr = "idel-pas.dat"
		idurfilestr = "idur-pas.dat"
		injvecfilestr = "injlist.dat"
		locstimfilestr = "locstim.dat"
		modestr = "passive"		
		recloclistfilestr = "recloclist.dat"
		runcontrolfilestr = "runcontrol-pas.ses"
		shapeplotfilestr = "shapeplot-pas.ses"
		savedatafilestr = "savedata-pas.ses"
		savedatadatafilestr = "savedata-pas.ses.fd1"
		savedataparamfilestr = "savedata-pas.ses.ft1"
		temprecfilestr = "temprec.dat"
		vdatfilestr = "vdat-pas.dat"
		vtplotfilestr = "vtplot-pas.ses"
		vxplotfilestr = "vxplot-pas.ses"
	
	} else if ($1 == 1 && $2 == 1) {

		doargfilestr = "doarg-act.dat"
		iampfilestr = "iamp-act.dat"
		iampvecfilestr = "iampvec-act.dat"		
		idelfilestr = "idel-act.dat"
		idurfilestr = "idur-act.dat"
		injvecfilestr = "injlist.dat"
		locstimfilestr = "locstim.dat"
		modestr = "active"		
		recloclistfilestr = "recloclist.dat"
		runcontrolfilestr = "runcontrol-act.ses"
		shapeplotfilestr = "shapeplot-act.ses"
		savedatafilestr = "savedata-act.ses"
		savedatadatafilestr = "savedata-act.ses.fd1"
		savedataparamfilestr = "savedata-act.ses.ft1"
		temprecfilestr = "temprec.dat"
		vdatfilestr = "vdat-act.dat"
		vtplotfilestr = "vtplot-act.ses"
		vxplotfilestr = "vxplot-act.ses"

	} else if ($1 == 0 && $2 == 0) {

		doargfilestr = "doarg-pas-def.dat"		
		iampfilestr = "iamp-pas-def.dat"
		iampvecfilestr = "iampvec-pas-def.dat"
		idelfilestr = "idel-pas-def.dat"
		idurfilestr = "idur-pas-def.dat"
		injvecfilestr = "injlist-def.dat"
		locstimfilestr = "locstim-def.dat"
		modestr = "passive-default"
		recloclistfilestr = "recloclist-def.dat"
		runcontrolfilestr = "runcontrol-pas-def.ses"
		shapeplotfilestr = "shapeplot-pas-def.ses"
		temprecfilestr = "temprec-def.dat"
		vtplotfilestr = "vtplot-pas-def.ses"
		vxplotfilestr = "vxplot-pas-def.ses"
	
	} else if ($1 == 1 && $2 == 0) {

		doargfilestr = "doarg-act-def.dat"		
		iampvecfilestr = "iampvec-act-def.dat"
		iampfilestr = "iamp-act-def.dat"		
		idelfilestr = "idel-act-def.dat"
		idurfilestr = "idur-act-def.dat"
		injvecfilestr = "injlist-def.dat"
		locstimfilestr = "locstim-def.dat"
		modestr = "active-default"
		recloclistfilestr = "recloclist-def.dat"
		runcontrolfilestr = "runcontrol-act-def.ses"
		shapeplotfilestr = "shapeplot-act-def.ses"
		temprecfilestr = "temprec-def.dat"
		vtplotfilestr = "vtplot-act-def.ses"
		vxplotfilestr = "vxplot-act-def.ses"
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// outputs max nsig of NEURON. Based on float_epsilon.
func getnsigmax() {local nsigmax

	// anything below 10 to the power of -nsigmax+1 must be discounted, as per 
	// the purpose of float_epsilon. Therefore nsigmax is maximal.
	nsigmax = int(abs(log10(float_epsilon)))+1

	return nsigmax
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// sets maximum precision format based on getnsigmax
proc setmaxform() {

	sprint(maxform, "%s%d%s", "%.", getnsigmax()-1, "le")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// sets maximum precision format based on getnsigmax for vector output
proc setmaxformvec() {

	sprint(maxformvec, "%s%d%s\t", "%.", getnsigmax()-1, "le")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes no argument.
// sets maximum precision format for time values based on nsigt

proc settform() {

	sprint(tform, "%s%d%s", "%.", nsigt-1, "le")
}
// --------------------------------------------------------------------------------



// ------------------------------settformvec---------------------------------------
// takes no argument.
// sets maximum precision format for time values based on nsigt for vector output
proc settformvec() {

	sprint(tformvec, "%s%d%s\t", "%.", nsigt-1, "le")
}
// --------------------------------------------------------------------------------



// -------------------------------setvform-----------------------------------------
// takes no argument.
// sets maximum precision format for voltage values based on nsigv
proc setvform() {

	sprint(vform, "%s%d%s", "%.", nsigv-1, "le")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes no argument.
// sets max precision format for voltage values based on nsigv for vector output
proc setvformvec() {

	sprint(vformvec, "%s%d%s\t", "%.", nsigv-1, "le")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc crveclist() {local k localobj tempmat
	
	$o1 = new List()
	
	tempmat = new Matrix(1, $2)
	
	for k = 0, $2-1 {

		$o1.append(tempmat.getcol(k))
		
		if (numarg() == 3) {

			$o1.o(k).resize($3)

		} else {

			$o1.o(k).resize(0)
		}		
	}

	return $o1
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc resizeveclist() {local k, q localobj templist

	templist = crveclist(templist, $2, $3)

	for k = 0, $o1.count-1 {

		for q = 0, $o1.o(k).size-1 {

			templist.o(k).x[q] = $o1.o(k).x[q]
		}
	}

	$o1 = crveclist($o1, $2, $3)

	for k = 0, $o1.count-1 {

		for q = 0, $o1.o(k).size-1 {

			$o1.o(k).x[q] = templist.o(k).x[q]
		}
	}

	return $o1
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc crvvarlist() {local k

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) a veclist object containting, as strings, combined section names and locations, i.e. \"soma(0.5)\""
			print "2) an object, which will become a new veclist"
			print "output: the voltage variable list version of 1), i.e. \"soma.v(0.5)\""
			stop
		}
	}

	strdef vvarstr, strtokleft, strtokright
	crveclist($o2, $o1.count)
	
	for k = 0, $o1.count-1 {

		sprint(vvarstr, $o1.o(k).label)
		strf.head(vvarstr, "[(]", strtokleft)
		strf.tail(vvarstr, "[(]", strtokright)
		sprint(vvarstr, "%s%s%s", strtokleft, ".v(", strtokright)

		$o2.o(k).label(vvarstr)
	}
}
// -------------------------------------------------------------------------------



// -------------------------------------------------------------------------------
// takes (1) either a number in scientific format or vecobj 
// outputs the number of significant figures after the decimal or, of vecobj, 
// the maximum number of significant figures after the decimal.
// not for general use (has issues).
func getnsig() {local maxlen, curlen, k localobj tempvec, templist

	setmaxform()
	maxlen = 0
	curlen = 0

	if (argtype(1) == 0) {

		sprint(maxnum, maxform, $1)
		maxlen = strf.head(maxnum, "[e]", tempstr)

		while (curlen <= maxlen) {

			curlen = strf.len(tempstr)

			sprint(trailzero, tempstr)
			strf.right(trailzero, curlen-1)

			if (!strcmp(trailzero, "0")) {

				strf.left(tempstr, curlen-1)
			
			} else {

				break
			}
		}

		// remove "." and first char
		return curlen-2
	
	} else {

		templist = new List()

		crveclist(templist, $o1.size)

		for k = 0, templist.count-1 {

			sprint(maxnum, maxform, abs($o1.x[k]))
			maxlen = strf.head(maxnum, "[e]", tempstr)
	
			while (curlen <= maxlen) {

				curlen = strf.len(tempstr)

				sprint(trailzero, tempstr)
				strf.right(trailzero, curlen-1)

				if (!strcmp(trailzero, "0")) {

					strf.left(tempstr, curlen-1)	
				
				} else {

					break
				}
			}

			templist.o(k).label(tempstr)
		}

		tempvec = new Vector()
		for k = 0, templist.count-1 {

			tempvec.append(strf.len(templist.o(k).label))
		}

		return tempvec.max-1
	}
}
// --------------------------------------------------------------------------------



// ---------------------------------setnsig----------------------------------------
// takes (1) any number; (2) nsig
// sets number to nsig.
func setnsig() {local k, l_, pow

	if ($2 > getnsigmax()) {

		print "nsig for setnsig must be less than or equal to ", getnsigmax(), "set by float_epsilon"
		stop
	}
	// the following 2 lines round the number to specified nsig
	// in tempstr using exponential notation
	sprint(format, "%s%d%s", "%.", $2-1, "le")
	sprint(tempstr, format, $1)
	// get num head in its entirety and length
	l_ = strf.head(tempstr, "[e]", numhead)
	// extract its power
	strf.tail(tempstr, "[e]", powstr)
	// scan numhead 
	sprint(format, "%s%d%s", "%", l_, "lf")
	sscanf(numhead, format, &k)
	// scan power
	sscanf(powstr, "%lf", &pow)
	// output the num
	k *= 10^pow

	return k
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getRMP() {local iidel, k localobj tempvec

	if (idata) {

		iidel = tdatvec.indwhere(">=", getvar(ses, idelfilestr))

		tempvec = new Vector()

		for k = 1, vdatmat.ncol-1 tempvec.append(vdatmat.getcol(k).mean(0, iidel))

		return tempvec.mean()
	
	} else {

		if (mode_ == 0) {

			return 0
		
		} else if (mode_ == 1) {

			return getvar(ses, "RMP-def.dat")
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// to delete any number that matches the boolean string operator (see indwhere in the
// NEURON programmer's reference for Vector)

obfunc delvec() {local ind

	while ((ind = $o3.indwhere($s1, $2)) > -1) {

		$o3.remove(ind)
	}

	return $o3
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// to delete 0's from vectors

obfunc delzerovec() {local k, chkzero, ind localobj tempvec

	tempvec = new Vector()

	for k = 0, $o1.size-1 {

		if ($o1.x[k] >= float_epsilon && $o1.x[k] <= float_epsilon) {

			tempvec.resize(tempvec.size+1)
			tempvec.x[tempvec.size-1] = k
		}
	}

	while (tempvec.size) {

		$o1.remove(tempvec.x[tempvec.size-1])
		tempvec.remove(tempvec.size-1)
	}

	return $o1
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// see delvec but for matrices

obfunc delmat() {local m localobj templist, tempvec

	templist = new List()
	tempvec = new Vector()

	for m = 0, $o3.nrow-1 {

		if (delvec($s1, $2, $o3.getrow(m)).size) {

			templist.append(delvec($s1, $2, $o3.getrow(m)))

			tempvec.resize(tempvec.size+1)
			tempvec.x[tempvec.size-1] = templist.o(templist.count-1).size
		}
	}

	if (templist.count && tempvec.size) {

		$o1 = new Matrix(templist.count, tempvec.max)

		for m = 0, $o1.nrow-1 {

			$o1.setrow(m, templist.o(m))
		}
	
	} else {

		$o1 = new Matrix(1, 1)
	}

	return $o1
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc delrowmat() {local m localobj templist

	templist = new List()

	if (argtype(1) == 0) {

		for m = 0, $o2.nrow-1 {

			if (m != $1) {

				templist.append($o2.getrow(m))
			}
		}
	
	} else if (argtype(1) == 1) {

		for m = 0, $o2.nrow-1 {

			if (!$o1.contains(m)) {

				templist.append($o2.getrow(m))
			}
		}
	}

	$o2 = new Matrix(templist.count, templist.o(0).size)

	for m = 0, $o2.nrow-1 {

		$o2.setrow(m, templist.o(m))
	}

	return $o2
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// see delzerovec but for matrices

obfunc delzeromat() {local m localobj templist, tempvec

	templist = new List()
	tempvec = new Vector()

	for m = 0, $o1.nrow-1 {
		
		if (delzerovec($o1.getrow(m)).size) {

			templist.append(delzerovec($o1.getrow(m)))

			tempvec.resize(tempvec.size+1)
			tempvec.x[tempvec.size-1] = templist.o(templist.count-1).size
		}
	}

	if (templist.count && tempvec.size) {

		$o1 = new Matrix(templist.count, tempvec.max)

		for m = 0, $o1.nrow-1 {

			$o1.setrow(m, templist.o(m))
		}		
	
	} else {

		$o1 = new Matrix(1, 1)
	}

	return $o1
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) dir, (2) matfilename, (3) obj. 
// For compatibility with file.getname(), also supports 2 argument structure with 
// (1) a combined matdir/matfilename (what file.getname() returns), and (2) matobj.
// outputs matobj and nrows (matfile input should be from a matrix output)
func getmat() {local nrows

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) one string combining path folder and file name, or two strings separating path folder and file name."
			print "2) a matrix object into which the matrix will be imported"
			stop
		}
	}

	if (numarg() == 2) {

		getfile.ropen($s1)

		$o2 = new Matrix()

		$o2.scanf(getfile)
			
		getfile.close()

		nrows = $o2.nrow
	
	} else if (numarg() == 3) {

		chkin()
		chdir($s1)
		
		getfile.ropen($s2)
		
		$o3 = new Matrix()
		
		$o3.scanf(getfile)
			
		getfile.close()
		
		nrows = $o3.nrow

		chkout()		
	}

	return nrows
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc importaisloc() {

	sprint(tempstr, "%s", "")
	sprint(teststr, "%s", " ")

	while (strf.len(teststr) > 0) {

		string_dialog("Please list axon initial segment sections (e.g. \"axon[0]\"). Return blank when done.", teststr)

		sprint(tempstr, "%s%s\n", tempstr, teststr)
	}

	writestr(ses, "aisloc.dat", tempstr, 0)

	sprint(tempstr, "%s", "")
	sprint(teststr, "%s", "")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc importreclocdata() {local rec, subloc, BB

	crveclist(recloclist, 10)

	sprint(tempstr, "%s", "")

	for rec = 0, recloclist.count-1 {

		if (rec) {

			string_dialog("Please enter the next recording location, if applicable. Format: axon[10](0.5). Return blank when done.", tempstr)

		} else {

			string_dialog("Please enter the injecting/recording location. Currently, only one is supported. Format: soma(0.5)", tempstr)
		}

		if (strf.len(tempstr) > 0) {

			recloclist.o(rec).label(tempstr)

		} else {

			break
		}
	}
	sprint(tempstr, "%s", "")

	rec = recloclist.count-1
	while (rec <= recloclist.count-1) {

		if (!strf.len(recloclist.o(rec).label)) {

			recloclist.remove(rec)
		
		} else {

			break
		}

		rec -= 1
	}
	writestr(ses, "locstim.dat", recloclist.o(0).label)

	injvec = new Vector(recloclist.count, 0)
	injvec.x[0] = 1
	savevec(ses, "injlist.dat", injvec)

	for rec = 0, recloclist.count-1 {

		sprint(tempstr, "%s%s\n", tempstr, recloclist.o(rec).label)
	}
	strf.left(tempstr, strf.len(tempstr)-1)
	writestr(ses, "recloclist.dat", tempstr)
	sprint(tempstr, "%s", "")

	// create voltage fit variables from recording locations	
	sublocvec = new Vector()
	loclist = crveclist(loclist, recloclist.count)

	for rec = 0, loclist.count-1 {
		
		// get recloc including section array and sublocation
		if (strf.substr(recloclist.o(rec).label, "(") > -1 && strf.substr(recloclist.o(rec).label, ")")) {

			// recloc including section array
			strf.head(recloclist.o(rec).label, "[(]", locstr)
			loclist.o(rec).label(locstr)

			// sublocation
			strf.tail(recloclist.o(rec).label, "[(]", sublocstr)
			strf.head(sublocstr, "[)]", sublocstr)

			// sscan sublocstr into subloc
			sscanf(sublocstr, "%g", &subloc)

			// append subloc into sublocvec
			if (subloc >= 0 && subloc <= 1) {

				sublocvec.append(subloc)
			
			} else {

				// in case sublocation badly specified
				sublocvec.append(0.5)			
			}
		}
	}

	// create fit variables list
	fitvarlist = crveclist(fitvarlist, recloclist.count)

	print "The following fit variables have been created:"

	for rec = 0, fitvarlist.count-1 {

		sprint(tempstr, "%s%s%g%s", loclist.o(rec).label, ".v(", sublocvec.x[rec], ")")
		fitvarlist.o(rec).label(tempstr)

		print fitvarlist.o(rec).label

		sprint(tempstr, "%s\n", fitvarlist.o(rec).label)
	}
	writestr(ses, "fitvarlist.dat", tempstr)
	strf.left(tempstr, strf.len(tempstr)-1)
	sprint(tempstr, "%s", "")

	// Bridge balance of each recording pipette.
	// Pipettes will be modelled explicity to parse out their biophysical contribution.
	BBvec = new Vector(recloclist.count, 1e6)

	BBqstr_left = "\nPlease enter bridge balance for pipette at "
	BBqstr_right = " (MOhm):"

	print "\nRecording pipettes will be modelled explicitly to parse their biophysical contribution out"

	for BB = 0, BBvec.size-1 {

		sprint(BBqstr, "%s%s%s", BBqstr_left, recloclist.o(BB).label, BBqstr_right)

		BBvec.x[BB] = 1e6*xred(BBqstr, 1, 1, 100)
	}
	savevec(ses, "BBvec.dat", BBvec)	
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc importblebdata() {

	sprint(tempstr, "%s", "")

	string_dialog("Please enter the final non-myelinated  section of the principal axon. Format: axon[20]", tempstr)

	writestr(ses, "axbleb_loc.dat", tempstr, 0)

	sprint(tempstr, "%s", "")
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes no arguments
// imports t, v(t) tab-delimited data, either as (t,v) or (t,v1,v2,...,vn)
proc importdata() {

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Will run importiamp() and importv(). No arguments required."
			stop
		}
	}

	importiamp()
	importv()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes no argument
// imports iamp into iampvec and saves iampvec.dat

proc importiamp() {local upiamp, iamp, tempsize, tempnum, firstamp

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Will import iamp from source iampvec or manual entry. No initial arguments required."
			stop
		}
	}

	mode_ = getvar(ses, "mode.dat")
	setfilestr(mode_, idata)

	print "Import current clamp injection amplitudes for ", modestr, " recordings:\n"
	
	upiampqstr = "Current-clamp amplitudes may be defined individually or collectively by vector upload.\nPlease select one of the following:\n1 = individual entry\n2 = vector upload"
	upiamp = xred(upiampqstr, 2, 1, 2)

	iampvec = new Vector()

	if (upiamp == 2) {

		chkin()
		chdir(root)
		
		getfile.chooser("r", "Please select dat file with injection amplitudes (nA)", "*.dat", "accept", "cancel", "root")
		
		if (getfile.chooser()) {

			getfile.ropen(getfile.getname())
			
			while (!getfile.eof) {

				iampvec.append(getfile.scanvar())
			}
				
			getfile.close()
		}

		chkout()
	
	} else if (upiamp == 1) {

		niampqstr = "\nPlease enter total number of injection protocol(s)"
		iampqstr_next = "Please enter the next injection amplitude (nA)"

		tempsize = xred(niampqstr, 1, 1, 100)
		
		firstamp = 1
		tempnum = 1
		
		while (tempnum <= tempsize) {

			if (firstamp) {

				if (tempsize == 1) {

					iampqstr_first = "Please enter the injection amplitude (nA)"

				} else if (tempsize > 1) {

					iampqstr_first = "Please enter the first injection amplitude (nA)"
				}

				iamp = xred(iampqstr_first, 0.5, -100, 100)

				firstamp = 0
			
			} else {

				iamp = xred(iampqstr_next, 0.5, -100, 100)
			}

			iampvec.append(iamp)
			
			tempnum += 1
		}
	}

	setmaxformvec()

	chkin()
	chdir(ses)
	
	writefile.wopen(iampvecfilestr)
	
	iampvec.printf(writefile, maxformvec)
	
	writefile.close()

	chkout()

	print iampvecfilestr, " saved in ", ses, "\n"
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// imports current injection and voltage response data

proc importv() {local k, rec, import localobj tempmat, vdatvec, tcmpvec

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Will import v from source data files (*.dat). No initial arguments required"
			stop
		}
	}

	nrec = getstrlist(ses, "recloclist.dat", recloclist)

	vdatlist = new List()

	mode_ = getvar(ses, "mode.dat")
	setfilestr(mode_, idata)

	print "\nImport ", modestr, " voltage responses:\n"

	importqstr = "Please select one of the following:\n\n(1) Import voltage responses individually for each injection amplitude at each recording location.\n(2) Import all voltage responses for all injection amplitudes at each recording location.\n\n(Should be used with trcsProcessor to ensure proper formatting)"
	
	import = xred(importqstr, 2, 1, 2)

	if (import == 1) {

		// obtain pathlist to vrec, which will also contain nrows.
		chkin()
		chdir(root)
		
		sprint(tempdir, "%s", root)
		crveclist(vpathlist, nrec)

		for k = 0, iampvec.size-1 {

			for rec = 0, recloclist.count-1 {

				sprint(tempstr, "%s%g%s%s", "Please select voltage responses for ", iampvec.x[k], " nA at ", recloclist.o(rec).label)

				getfile.chooser("r", tempstr, "*.dat", "accept", "cancel", tempdir)

				if (getfile.chooser()) {

					sprint(tempstr, "%s", getfile.getname())
					vpathlist.o(rec).label(tempstr)
					sprint(tempdir, "%s", getfile.dir())
					
					getfile.close()
				}
			}
		}

		chkout()

		// first var in trcsProcessor-formatted mat should be nrows
		// start with first vrec...
		nrows = getmat(vpathlist.o(0).label, tempmat)
		// ncols for vdatmat must 1 (time) + nrec*iampvec.size
		ncols = 1 + nrec * iampvec.size

		if (tempmat.ncol-1 != iampvec.size) {
			
			print "Number of imported v for ", recloclist.o(0).label, " does not correspond to that of injection amplitudes"
			stop
		}
		
		// create vdatmat
		vdatmat = new Matrix(nrows, ncols)
		// fill vdatmat
		// start with laying out first vrec (the inj/rec)...
		// set time
		vdatmat.setcol(0, tempmat.getcol(0))
		tdatvec = new Vector()
		tdatvec.append(vdatmat.getcol(0))
		// fill remaining v cols
		for col = 0, tempmat.ncol-2 {

			vdatmat.setcol(nrec*col+1, tempmat.getcol(col+1))
		}

		if (nrec > 1) {

			for rec = 1, nrec-1 {

				nrows = getmat(vpathlist.o(rec).label, tempmat)

				if (nrows != vdatmat.nrow) {

					print "Number of rows for ", recloclist.o(rec).label, "does not correspond to those already imported"
					stop
				
				} else {

					tcmpvec = new Vector()
					tcmpvec.append(tempmat.getcol(0))

					if (tcmpvec.size != tdatvec.size || (tcmpvec.x[0] != tdatvec.x[0] && tcmpvec.x[1] != tdatvec.x[1] && tcmpvec.x[tcmpvec.size-1] != tdatvec.x[tdatvec.size-1])) {

						print "Time vectors for ", recloclist.o(rec).label, " and ", recloclist.o(rec).label, "do not match"
						stop

					} else {

						for col = 0, tempmat.ncol-2 {

							vdatmat.setcol(nrec*col+rec+1, tempmat.getcol(col+1))
						}
					}
				}
			}
		}
	}

	if (import == 2) {
		
		// obtain pathlist to vrec, which will also contain nrows.
		chkin()
		chdir(root)
		
		sprint(tempdir, "%s", root)
		crveclist(vpathlist, nrec)
		
		for rec = 0, recloclist.count-1 {

			sprint(tempstr, "%s%s", "Please select voltage responses for ", recloclist.o(rec).label)
			getfile.chooser("r", tempstr, "*.dat", "accept", "cancel", tempdir)
		
			if (getfile.chooser()) {

				sprint(tempstr, "%s", getfile.getname())
				vpathlist.o(rec).label(tempstr)
				sprint(tempdir, "%s", getfile.dir())
				
				getfile.close()
			}
		}

		chkout()

		// first var in trcsProcessor-formatted mat should be nrows
		// start with first vrec...
		nrows = getmat(vpathlist.o(0).label, tempmat)
		// ncols for vdatmat must 1 (time) + nrec*iampvec.size
		ncols = 1 + nrec * iampvec.size

		if (tempmat.ncol-1 != iampvec.size) {
			
			print "Number of imported v for ", recloclist.o(0).label, " does not correspond to that of injection amplitudes"
			stop
		}
		
		// create vdatmat
		vdatmat = new Matrix(nrows, ncols)
		// fill vdatmat
		// start with laying out first vrec (the inj/rec)...
		// set time
		vdatmat.setcol(0, tempmat.getcol(0))
		tdatvec = new Vector()
		tdatvec.append(vdatmat.getcol(0))
		// fill remaining v cols
		for col = 0, tempmat.ncol-2 {

			vdatmat.setcol(nrec*col+1, tempmat.getcol(col+1))
		}

		if (nrec > 1) {

			for rec = 1, nrec-1 {

				nrows = getmat(vpathlist.o(rec).label, tempmat)

				if (nrows != vdatmat.nrow) {

					print "Number of rows for ", recloclist.o(rec).label, "does not correspond to those already imported"
					stop
				
				} else {

					tcmpvec = new Vector()
					tcmpvec.append(tempmat.getcol(0))

					if (tcmpvec.size != tdatvec.size || (tcmpvec.x[0] != tdatvec.x[0] && tcmpvec.x[1] != tdatvec.x[1] && tcmpvec.x[tcmpvec.size-1] != tdatvec.x[tdatvec.size-1])) {

						print "Time vectors for ", recloclist.o(rec).label, " and ", recloclist.o(rec).label, "do not match"
						stop

					} else {

						for col = 0, tempmat.ncol-2 {

							vdatmat.setcol(nrec*col+rec+1, tempmat.getcol(col+1))
						}
					}
				}
			}
		}
	}

	// save vdatmat
	nsigv = getnsig(vdatmat.getcol(1))
	setvformvec()
	savemat(ses, vdatfilestr, vdatmat, vformvec)
	writebit(ses, "idata.dat", 1)

	sprint (tempstr, "%s%s", ses, vdatfilestr)
	print "\nVoltage responses imported and saved as ", tempstr
	print "Changes will be reflected in the model at the next open."
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc appenddata() {local k, iapp, iiapp, m, y, f localobj tempmat, newvdatmat

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "You will be required to enter the injection amplitude to append with its associated voltage data."
			print "output: these injection amplitude/voltage data appended within iampvec/vdat"
			stop
		}
	}

	strdef iappstr
	y = string_dialog("Please enter injection amplitude to append (nA)", iappstr)
	if (y) {

		sscanf(iappstr, "%lf", &iapp)
		iampvec.append(iapp)
		iampvec.sort()
		iiap = iampvec.indwhere("==", iapp)

		strdef vappstr
		sprint(vappstr, "%s%g%s", "Please import all voltage responses for ", iampvec.x[iiap], " nA")
				
		getfile.chooser("r", vappstr, "*.dat", "accept", "cancel", tempdir)

		if (getfile.chooser()) {

			sprint(vappstr, "%s", getfile.getname())
			sprint(tempdir, "%s", getfile.dir())
			getfile.close()
		}

		m = getmat(tempdir, vappstr, tempmat)

		if (m != vdatmat.nrow || tempmat.x[0][0] != vdatmat.x[0][0]) {

			print "Time columns must match."
			stop
		}

		if (tempmat.ncol-1 != nf) {

			print "Number of imported voltage columns must match number of fit variables."
			stop
		}

		newvdatmat = new Matrix(vdatmat.nrow, vdatmat.ncol+nf)
		newvdatmat.setcol(0, vdatmat.getcol(0))

		for k = 0, iampvec.size-1 {

			for f = 0, nf-1 {

				if (k < iiap){

					newvdatmat.setcol(k*nf+1+f, vdatmat.getcol(k*nf+1+f))

				} else if (k == iiap) {

					newvdatmat.setcol(k*nf+1+f, tempmat.getcol(1+f))
				
				} else {

					newvdatmat.setcol(k*nf+1+f, vdatmat.getcol(k*nf+1+f-nf))
				}
			}
		}

		vdatmat = new Matrix(vdatmat.nrow, newvdatmat.ncol)
		for k = 0, vdatmat.ncol-1 vdatmat.setcol(k, newvdatmat.getcol(k))

		savevec(ses, iampvecfilestr, iampvec, maxformvec)
		savemat(ses, vdatfilestr, vdatmat, vformvec)
		setstimpanel()
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) seclist; (2) destlist
// output secnames in destlist
proc seclist2list() {local countsec, counter

	countsec = 0
	forsec $o1 countsec += 1
	crveclist($o2, countsec)
	
	if (countsec == $o2.count) {

		counter = 0

		forsec $o1 {

			$o2.o(counter).label(secname())
			counter += 1
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc list2seclist() {local k

	$o2 = new SectionList()

	for k = 0, $o1.count-1 {

		if (strf.len($o1.o(k).label)) {

			forsec $o1.o(k).label $o2.append()
		}
	}

	return $o2
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) loclist (i.e. recloclist); (2) obj
// outputs loc as secname (= no subloc) in objlist (strlist)
obfunc loclist2seclist() {local k

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) A list object containing combined section locations and sublocations, i.e. \"axon[0](0.5)\", in string format"
			print "2) Any object"
			print "output: a new list in the provided object containing only the section names, i.e. \"axon[0]\", in the same string format"
			stop
		}
	}

	$o2 = crveclist($o2, $o1.count)

	for k = 0, $o1.count-1 {

		strf.head($o1.o(k).label, "[(]", tempstr)
		$o2.o(k).label(tempstr)
	}

	tempstr = ""

	return $o2
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) loclist (i.e. recloclist); (2) obj
// outputs subloc of loc in objlist (strlist)
obfunc loclist2subloclist() {local k

	$o2 = crveclist($o2, $o1.count)

	for k = 0, $o1.count-1 {

		strf.tail($o1.o(k).label, "[(]", tempstr)
		strf.left(tempstr, strf.len(tempstr)-1)
		$o2.o(k).label(tempstr)
	}

	tempstr = ""

	return $o2
}
// --------------------------------------------------------------------------------



// -------------------------------sec2secnum---------------------------------------
func sec2secnum() {local u

	if (strf.substr($s1, "[") && strf.substr($s1, "]")) {

		strf.tail($s1, "[[]", tempstr)
		strf.head(tempstr, "[]]", tempstr)

		sscanf(tempstr, "%lf", &u)
		return u

	} else {

		return -1
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc getcoremodeltype() {local rec, SOf, AXf, DEf

	sprint(modeltypestr, "%s", "")
	sprint(reclocstr, "%s", "")
	DEFAULT = 0

	// count locations
	SOf = 0
	AXf = 0
	DEf = 0

	sprint(SOstr, "%s", "soma")
	sprint(AXstr, "%s", "axon")
	sprint(DEstr, "%s", "dend")
	sprint(APstr, "%s", "apic")

	// define number and location of recordings
	if (nrec) {

		for rec = 0, nrec-1 {

			if (strf.substr(recloclist.o(rec).label, SOstr) > -1) {
			
				SOf += 1
			
			} else if (strf.substr(recloclist.o(rec).label, AXstr) > -1) {
			
				AXf += 1
			
			} else if ((strf.substr(recloclist.o(rec).label, DEstr) > -1) || (strf.substr(recloclist.o(rec).label, APstr) > -1)) {

				DEf += 1
			}
		}
	}

	// labels for combination of fit variables
	SOAX = 0
	SODE = 0
	SO = 0
	AX = 0
	DE = 0

	// Establish model type as a function of fit variable locations
	if (SOf > 0 && AXf > 0 && DEf == 0) {

		SOAX = 1
		modeltypestr = "SOAX"

		sprint(reclocstr, "%d%s%d%s", SOf, " somatic and ", AXf, " axonal recording locations found")
	}

	if (SOf > 0 && DEf > 0 && AXf == 0) {

		SODE = 1
		modeltypestr = "SODE"

		sprint(reclocstr, "%d%s%d%s", SOf, " somatic and ", DEf, " dendritic recording locations found")
	}

	if (SOf > 0 && AXf == 0 && DEf == 0) {

		SO = 1
		modeltypestr = "SO"

		sprint(reclocstr, "%d%s", SOf, " somatic recording location(s) found")
	}

	if (SOf == 0 && AXf == 0 && DEf == 0) {

		DEFAULT = 1
		modeltypestr = "DEFAULT"

		sprint(reclocstr, "%s", "No recording locations found")
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc setcelltype() {

	strdef celltypeqstr
	sprint(celltypeqstr, "%s", "Please select cell type, beginning with the animal type...\nCurrent choices include:\n0) Non-defined\n1) Rat\n2) Human\t")
	animaltype = xred(celltypeqstr, 1, 0, 2)

	sprint(celltypeqstr, "%s", "Please continue defining the cell type, with respect to cellular region\nCurrent choices include:\n0) Non-defined region\n1) Primary somatosensory cortex\n2) Temporal association cortex\t")
	regiontype = xred(celltypeqstr, 1, 0, 2)

	sprint(celltypeqstr, "%s", "Please continue defining the cell type, with respect to layer\nCurrent choices include:\n0) Non-defined layer\n1) Layer 5\t")
	layertype = xred(celltypeqstr, 1, 0, 1)

	strdef celltype
	if (animaltype == 1) {

		sprint(celltype, "%s", "Rn\n")

	} else if (animaltype == 2) {

		sprint(celltype, "%s", "Hs\n")

	} else {

		sprint(celltype, "%s", "ND\n")	
	}

	if (regiontype == 1) {

		sprint(celltype, "%s%s", celltype, "S1\n")

	} else if (regiontype == 2) {

		sprint(celltype, "%s%s", celltype, "TeAC\n")

	} else {

		sprint(celltype, "%s%s", celltype, "ND\n")	
	}

	if (layertype == 1) {

		sprint(celltype, "%s%s", celltype, "L5")

	} else {

		sprint(celltype, "%s%s", celltype, "ND")
	}
	writestr(ses, "celltype.dat", celltype)
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc getcelltype() {local nline, k localobj celltypevec, tempvec

	if (chkdir(ses, "celltype.dat\n")) {

		nline = getnline(ses, "celltype.dat")
		celltypevec = new Vector(nline)
		strdef celltype

		for k = 0, celltypevec.size-1 {

			tempvec = getline(ses, "celltype.dat", k)

			if (!k) {

				if (!strcmp(tempvec.label, "Rn")) {

					celltypevec.x[k] = 1
					sprint(celltype, "%s%s", celltype, "Rn-")
				
				} else if (!strcmp(tempvec.label, "Hs")) {

					celltypevec.x[k] = 2
					sprint(celltype, "%s%s", celltype, "Hs-")
				
				} else {

					celltypevec.x[k] = 0
					sprint(celltype, "%s%s", celltype, "NON-DEFINED-")
				}
			
			} else if (k == 1) {

				if (!strcmp(tempvec.label, "S1")) {

					celltypevec.x[k] = 1
					sprint(celltype, "%s%s", celltype, "S1-")
				
				} else if (!strcmp(tempvec.label, "TeAC")) {

					celltypevec.x[k] = 2
					sprint(celltype, "%s%s", celltype, "TeAC-")
				
				} else {

					celltypevec.x[k] = 0
					sprint(celltype, "%s%s", celltype, "NON-DEFINED-")
				}
			
			} else if (k == 2) {

				if (!strcmp(tempvec.label, "L5")) {

					celltypevec.x[k] = 1
					sprint(celltype, "%s%s", celltype, "L5")
				
				} else {

					celltypevec.x[k] = 0
					sprint(celltype, "%s%s", celltype, "NON-DEFINED")
				}
			}
		}
	}

	celltypevec.label(celltype)

	return celltypevec
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc print_celltype() {

	print "Cell type: ", celltype
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc print_axontype() {

	if (axontype == 1) {

		print "Axon type: NOMY"
	}

	if (axontype == 2) {

		print "Axon type: SC"
	}

	if (axontype == 3) {

		print "Axon type: DC"
	}

	if (axontype == 4) {

		print "Axon type: DCPARA"
	}
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
// takes (1) optional quiet argument = anything. requires axontype.dat in ses.
// outputs axontype (1-5) and associated myelin code (nomy, DC, SC, etc)

func getaxontype() {local axontype

	axontype = getvar(ses, "axontype.dat")
	
	if (axontype == 1) {

		NOMY = 1
		SC = 0
		DC = 0
		DCPARA = 0
		axontypestr = "NOMY"
	
	}

	if (axontype == 2) {

		NOMY = 0
		SC = 1
		DC = 0
		DCPARA = 0
		axontypestr = "SC"
	
	}

	if (axontype == 3) {

		NOMY = 0
		SC = 0
		DC = 1
		DCPARA = 0
		axontypestr = "DC"
	
	}

	if (axontype == 4) {

		NOMY = 0
		SC = 0
		DC = 0
		DCPARA = 1
		axontypestr = "DCPARA"
	}
	
	return axontype
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) number of pipettes, (2) listobj for pipseclists
// outputs that number of pipettes

func createpip() {

	npip = $1
	piplist = new List()

	// pipette tip length, in cm
	pipL = 0.2

	// area of jth compartment
	sum_Aj = PI*(0.5^2)*(1e-04)^2 

	for jpip = 1, 5 {
		
		sum_Aj += PI*((0.5*(1.4*jpip))^2)*(1e-04)^2
	}

	for jpip = 6, 199 {
		
		sum_Aj += PI*((0.5*0.97*(jpip^1.19))^2)*(1e-04)^2
	}

	for ipip = 0, npip-1 {

		sprint(decpipseclist, "%s%d", "objref pipette", ipip+1)
		execute(decpipseclist)

		sprint(crpipseclist, "%s%d%s", "pipette", ipip+1, " = new SectionList()")
		execute(crpipseclist)

		sprint(crcurpip, "%s%d%s", "create pip", ipip+1, "[200]")
		execute(crcurpip)

		sprint(crfirstsec, "%s%d%s%d%s", "pip", ipip+1, "[0] {pipette", ipip+1, ".append() pt3dadd(0,0,0,1) pt3dadd(piploc*10,2,0,1) L = 10}")
		execute(crfirstsec)

		piploc *= -1

		sprint(crstarttip, "%s%d%s%d%s%d%s%d%s", "pip", ipip+1, "[jpip] {pipette", ipip+1, ".append() diam = 1.4*jpip L = 10 connect pip", ipip+1, "[jpip](0), pip", ipip+1, "[jpip-1](1)}")
		
		for jpip = 1, 5 {

			execute(crstarttip)
		}

		sprint(crremtip, "%s%d%s%d%s%d%s%d%s", "pip", ipip+1, "[jpip] {pipette", ipip+1, ".append() diam = 0.97*jpip^1.19 L = 10 connect pip", ipip+1, "[jpip](0), pip", ipip+1, "[jpip-1](1)}")
		
		for jpip = 6, 199 {

			execute(crremtip)
		}

		sprint(piplistappend, "%s%d%s", "piplist.append(pipette", ipip+1, ")")
		execute(piplistappend)
	}

	return npip
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) strlist of locations
// connects available pipettes to these.

proc conpip() {local loc, tempnum

	if (npip == $o1.count) { 

		for loc = 0, $o1.count-1 {

			sprint(tokpip, "%s%d%s", "connect pip", loc+1, "[0](0), ")
			
			if ((tempnum = strf.substr($o1.o(loc).label, "[0]")) > -1) {
				
				sprint(tempstr, $o1.o(loc).label)
				strf.left(tempstr, tempnum)

				sprint(teststr, $o1.o(loc).label)
				strf.right(teststr, tempnum+3)

				sprint(tempstr, "%s%s", tempstr, teststr)

				sprint(strpipc, "%s%s", tokpip, tempstr)

			} else {

				sprint(strpipc, "%s%s", tokpip, $o1.o(loc).label)
			}
			
			execute(strpipc)
		}
	
	} else {

		print "Error: ", npip, "pipettes found for ", $o1.count, "locations"
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) a first section, in a secref object, and (2) a sectionlist, into which 
// section children belonging to the trunk defined by the first section will be
// appended. Note: based on 12 L5 pyramidal cells.

proc findtrunk() {local countsec, lbound, tinyl, ch, gch, cmaxdiam localobj cdiamvec

	lbound = 1.5
	tinyl = 0.75
	secref = $o1
	countsec = 0
	forsec $o2 countsec += 1
	
	// to append the first section the first time, avoiding recount of sectionlist
	if (!countsec && countsecflag) {

		secref.sec $o2.append()
		countsecflag = 0
	}
	
	// keep track of stack size to stay under default nstack
	if (stack < nstack) {

		cdiamvec = new Vector()
		secref.sec sprint(secstr, secname())

		if (secref.nchild > 1) {

			for ch = 0, secref.nchild-1 secref.child[ch] {

				if (!issection("pip.*")) {

					sprint(tempstr, secname())

					if (secoricmp(secstr, tempstr)) {

						cdiamvec.append(diam(0))

					} else {

						if (L < lbound && L > tinyl) {

							tsecref = new SectionRef()

							if (tsecref.nchild) {

								for gch = 0, tsecref.nchild-1 tsecref.child[gch] {

									sprint(gchstr, secname())
								
									if (secoricmp(secstr, tempstr, gchstr)) tsecref.sec cdiamvec.append(diam(0))
								}
							
							} else {

								cdiamvec.append(diam(0))
							}

						} else if (L < tinyl) {

							cdiamvec.append(diam(0))
						}

						if (L > lbound && secref.sec.L < lbound) {

							secref.parent sprint(gparstr, secname())

							if (secoricmp(gparstr, tempstr)) cdiamvec.append(diam(0))
						}
					}
				}
			}
		
		} else if (secref.nchild == 1) {

			secref.child[0] if (!issection("pip.*")) cdiamvec.append(diam(0))
		
		}

		stack += 5*secref.nchild

		if (cdiamvec.size > 0) {
	
			cmaxdiam = cdiamvec.max
				
			for ch = 0, secref.nchild-1 secref.child[ch] {
				
				if (diam(0) == cmaxdiam) {
				
					$o2.append()
					tsecref = new SectionRef()
				}	
			}

			stack += secref.nchild

			piponly = 0

			if (tsecref.nchild == 1) {

				tsecref.child[0] if (issection("pip.*")) piponly = 1
			}

			if (tsecref.nchild && !piponly) {

				if (stack < nstack) {

					findtrunk(tsecref, $o2)

				} else {

					// exit findtrunk and call it again until done
					stack = 0
					ftcount += 1
				}

			} else {

				// final exit from findtrunk
				ftec = 0
				stack = 0
				countsecflag = 1
			}			
		
		} else {

			// final exit from findtrunk
			ftec = 0
			stack = 0
			countsecflag = 1
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// takes (1) any string section name with location (i.e. soma(0.5))
// returns the section sublocation (i.e. 0.5)

func getsubloc() {local subloc

	strf.tail($s1, "[(]", tempstr)
	strf.head(tempstr, "[)]", tempstr)

	sscanf(tempstr, "%lf", &subloc)

	return subloc
}
// --------------------------------------------------------------------------------



// -------------------------------writebit-----------------------------------------
// integers only, usually 1 or 0.
// takes (1) output dir, (2) filename; (3) integer
proc writebit() {

	chkin()
	chdir($s1)
	
	writefile.wopen($s2)
	
	writefile.printf("%d", $3)
	
	writefile.close()

	chkout()
}
// --------------------------------------------------------------------------------



// -------------------------------writenum-----------------------------------------
// takes (1) output dir, (2) filename; (3) some real number, (4) optional format
proc writenum() {

	chkin()
	chdir($s1)
	
	writefile.wopen($s2)
	
	if (numarg() == 4) {
	
		writefile.printf($s4, $3)
	
	} else {
	
		setmaxform()
		writefile.printf(maxform, $3)
	}
	
	writefile.close()

	chkout()
}
// --------------------------------------------------------------------------------



// ------------------------------getsecang-----------------------------------------
// takes (1) secname. requires a 3D section.
// outputs angle orientation of section.
func getsecang() {local k, n

	forsec $s1 {

		xcvec = new Vector()
		ycvec = new Vector()

		n = n3d()
		
		for k = 0, n-1 {

			xcvec.append(x3d(k))
			ycvec.append(y3d(k))
		}
	}

	// gauge average movement in each direction
	avgxcvec = new Vector()
	avgycvec = new Vector()

	for k = 0, n-2 {

		avgxcvec.append(xcvec.x[k+1] - xcvec.x[k])
		avgycvec.append(ycvec.x[k+1] - ycvec.x[k])
	}

	avgx = abs(avgxcvec.mean) + float_epsilon
	avgy = abs(avgycvec.mean) + float_epsilon

	secang = atan(avgy/avgx)

	return secang
}
// --------------------------------------------------------------------------------



// ----------------------------secoricmp-------------------------------------------
// compare two sections for sharing the same orientiation.
// takes (1) secname1, (2) secname2, or more (currently 3). If more than 2, will 
// compare average of first n-1 to n. requires 3D sections.
// outputs 1 if sections share the same orientation (within +/-30 deg)
func secoricmp() {local k, secangavg localobj templist, tempvec

	templist = new List()
	tempvec = new Vector()

	crveclist(templist, numarg())

	templist.o(0).label($s1)
	templist.o(1).label($s2)
	if (numarg() == 3) templist.o(2).label($s3)

	for k = 0, templist.count-1 tempvec.append(getsecang(templist.o(k).label))

	if (numarg() > 2) {

		secangavg = tempvec.mean(0, tempvec.size-2)

	} else {

		secangavg = tempvec.x[0]		
	}

	if ((secangavg < tempvec.x[tempvec.size-1] + PI/6) && (secangavg > tempvec.x[tempvec.size-1] - PI/6)) {

		return 1

	} else {

		return 0
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
// Will check for the presence of a folder of filename in a provided  directory. 
// The directory is provided as a string path, and the checked-for folder  or 
// filename within as a test string. Either checked for folder or filename can be 
// a substring.
// takes (1) dir, (2) str

func chkdir() {

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Purpose: Will check for the presence of a folder of filename in a provided  directory."
			print "Enter:"
			print "1) Path directory (complete - str)."
			print "2) Folder or filename to be checked for (str - can be a substring)."
			stop
		}
	}	

	if (strf.len($s2) > 0) {

		chkin()
		chdir($s1)

		sprint(teststr, "%s", "")
		system("ls", teststr)

		if (strf.substr(teststr, $s2) > -1) {

			chkout()
				
			return 1

		} else {

			chkout()

			return 0
		}
	
	} else {

		print "Please enter a non-empty folder or filename string to check within ", $s1
	
		return 0
	}
}
// --------------------------------------------------------------------------------




// --------------------------------------------------------------------------------
proc sysdir() {
	
	chkin()
	chdir($s1)

	system($s2)

	chkout()
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
func getdist() {

	if (numarg() == 1 && argtype(1) == 2) {

		if (!strcmp($s1, "help")) {

			print "Enter:"
			print "1) the desired starting section name (string) at which the path begins, e.g. \"axon[10]\""
			print "2) the desired starting location within the start section (0-1)"
			print "3) the desired ending section name (string) at which the path ends, e.g. \"axon[20]\""
			print "4) the desired ending location within the start section (0-1)"
			stop
		}
	}

	forsec $s1 {

		distance(0, $2)
	}
	
	forsec $s3 {

		return distance($4)
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc crdir() {

	if (!chkdir($s1, $s2)) {

		chkin()
		chdir($s1)
		
		sprint(tempdir, "%s%s", "mkdir ./", $s2)
		system(tempdir)
		print "Directory ", $s2, " created in ", $s1

		chkout()

	} else {

		if (numarg() == 3) {

			if ($3) {
		
				sprint(tempstr, "%s%s", $s2, "_copy")
				sprint($s2, tempstr)

				crdir($s1, $s2)
			}
		}
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
obfunc getdirlist() {local nline, line, k localobj tempobj

	sprint(commstr, "%s%s", "ls ", $s1)

	sprint(rstr, "%s", "")

	system(commstr, rstr)

	if (strf.len(rstr)) {

		// number of folders and their names
		writestr($s1, "templog.dat", rstr, 0)

		nline = getnline($s1, "templog.dat")

		$o2 = crveclist($o2, nline)

		for line = 0, nline-1 {

			tempobj = getline($s1, "templog.dat", line)
			
			if (strf.len(tempobj.label)) {

				if (!(strf.substr($o2.o(k).label, ".dat") > -1 || strf.substr($o2.o(k).label, ".hoc") > -1 || strf.substr($o2.o(k).label, ".ses") > -1 || strf.substr($o2.o(k).label, ".type") > -1 || strf.substr($o2.o(k).label, ".txt") > -1 || strf.substr($o2.o(k).label, ".ffs") > -1)) {

					$o2.o(line).label(tempobj.label)
				}
			}
		}

		// remove templog
		rmdir($s1, "templog.dat")

		// clean up dirlist from superfluous entries
		k = $o2.count-1
		
		while (k >= 0) {

			if (!strf.len($o2.o(k).label)) {

				$o2.remove(k)				
			}

			k -= 1
		}
	
	} else {

		$o2 = new List()
	}

	return $o2
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc rmdir() {

	if (chkdir($s1, $s2)) {

		chkin()
		chdir($s1)

		sprint(commstr, "%s%s", "rm -rf ", $s2)
		system(commstr)

		chkout()
	}
}
// --------------------------------------------------------------------------------



// --------------------------------------------------------------------------------
proc set_maxtime() {local maxtime_hours, line localobj templist, tempvec

	sprint(qstr, "%s%g%s", "\nPlease enter the maximum optimization run time (hours):\n(Currently ", maxtime/3600, " hour(s))\t")
	maxtime = 3600*xred(qstr, 42, 0.25, 42)
	sprint(qstr, "%s", "")

	if (chkdir(ses, "time.dat")) {

		templist = crveclist(templist, getnline(ses, "time.dat"))

		for line = 0, templist.count-1 {

			tempvec = getline(ses, "time.dat", line)
			templist.o(line).label(tempvec.label)
		}
	}

	sprint(tempstr, "%s%g%s", "maxtime = ", maxtime_hours, "*3600")
	for line = 1, templist.count-1 {

		sprint(tempstr, "%s\n%s", tempstr, templist.o(line).label)
	}

	writestr(ses, "time.dat", tempstr)
	sprint(tempstr, "%s", "")
}
// --------------------------------------------------------------------------------
